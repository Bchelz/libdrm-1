diff --git a/libdrm/nouveau/Makefile.am b/libdrm/nouveau/Makefile.am
index 688eeca..490ce57 100644
--- a/libdrm/nouveau/Makefile.am
+++ b/libdrm/nouveau/Makefile.am
@@ -18,9 +18,6 @@ libdrm_nouveau_la_SOURCES = \
 			    nouveau_notifier.c \
 			    nouveau_bo.c \
 			    nouveau_resource.c \
-			    nouveau_dma.c \
-			    nouveau_fence.c \
-			    nouveau_dma.h \
 			    nouveau_private.h
 
 libdrm_nouveaucommonincludedir = ${includedir}/nouveau
diff --git a/libdrm/nouveau/nouveau_bo.c b/libdrm/nouveau/nouveau_bo.c
index fea3a7d..520d5d7 100644
--- a/libdrm/nouveau/nouveau_bo.c
+++ b/libdrm/nouveau/nouveau_bo.c
@@ -49,7 +49,7 @@ nouveau_bo_info(struct nouveau_bo_priv *nvbo, struct drm_nouveau_gem_info *arg)
 {
 	nvbo->handle = nvbo->base.handle = arg->handle;
 	nvbo->domain = arg->domain;
-	nvbo->size = nvbo->base.size = arg->size;
+	nvbo->size = arg->size;
 	nvbo->offset = arg->offset;
 	nvbo->map_handle = arg->map_handle;
 	nvbo->base.tile_mode = arg->tile_mode;
@@ -91,28 +91,6 @@ nouveau_bo_ufree(struct nouveau_bo_priv *nvbo)
 }
 
 static void
-nouveau_bo_kfree_nomm(struct nouveau_bo_priv *nvbo)
-{
-	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
-	struct drm_nouveau_mem_free req;
-
-	if (nvbo->map) {
-		drmUnmap(nvbo->map, nvbo->size);
-		nvbo->map = NULL;
-	}
-
-	req.offset = nvbo->offset;
-	if (nvbo->domain & NOUVEAU_BO_GART)
-		req.flags = NOUVEAU_MEM_AGP | NOUVEAU_MEM_PCI;
-	else
-	if (nvbo->domain & NOUVEAU_BO_VRAM)
-		req.flags = NOUVEAU_MEM_FB;
-	drmCommandWrite(nvdev->fd, DRM_NOUVEAU_MEM_FREE, &req, sizeof(req));
-
-	nvbo->handle = 0;
-}
-
-static void
 nouveau_bo_kfree(struct nouveau_bo_priv *nvbo)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
@@ -121,11 +99,6 @@ nouveau_bo_kfree(struct nouveau_bo_priv *nvbo)
 	if (!nvbo->handle)
 		return;
 
-	if (!nvdev->mm_enabled) {
-		nouveau_bo_kfree_nomm(nvbo);
-		return;
-	}
-
 	if (nvbo->map) {
 		munmap(nvbo->map, nvbo->size);
 		nvbo->map = NULL;
@@ -137,51 +110,6 @@ nouveau_bo_kfree(struct nouveau_bo_priv *nvbo)
 }
 
 static int
-nouveau_bo_kalloc_nomm(struct nouveau_bo_priv *nvbo)
-{
-	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
-	struct drm_nouveau_mem_alloc req;
-	int ret;
-
-	if (nvbo->handle)
-		return 0;
-
-	if (!(nvbo->flags & (NOUVEAU_BO_VRAM|NOUVEAU_BO_GART)))
-		nvbo->flags |= (NOUVEAU_BO_GART | NOUVEAU_BO_VRAM);
-
-	req.size = nvbo->size;
-	req.alignment = nvbo->align;
-	req.flags = 0;
-	if (nvbo->flags & NOUVEAU_BO_VRAM)
-		req.flags |= NOUVEAU_MEM_FB;
-	if (nvbo->flags & NOUVEAU_BO_GART)
-		req.flags |= (NOUVEAU_MEM_AGP | NOUVEAU_MEM_PCI);
-	if (nvbo->flags & NOUVEAU_BO_TILED) {
-		req.flags |= NOUVEAU_MEM_TILE;
-		if (nvbo->flags & NOUVEAU_BO_ZTILE)
-			req.flags |= NOUVEAU_MEM_TILE_ZETA;
-	}
-	req.flags |= NOUVEAU_MEM_MAPPED;
-
-	ret = drmCommandWriteRead(nvdev->fd, DRM_NOUVEAU_MEM_ALLOC,
-				  &req, sizeof(req));
-	if (ret)
-		return ret;
-
-	nvbo->handle =
-	nvbo->map_handle = req.map_handle;
-	nvbo->size = req.size;
-	nvbo->offset = req.offset;
-	if (req.flags & (NOUVEAU_MEM_AGP | NOUVEAU_MEM_PCI))
-		nvbo->domain = NOUVEAU_BO_GART;
-	else
-	if (req.flags & NOUVEAU_MEM_FB)
-		nvbo->domain = NOUVEAU_BO_VRAM;
-
-	return 0;
-}
-
-static int
 nouveau_bo_kalloc(struct nouveau_bo_priv *nvbo, struct nouveau_channel *chan)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
@@ -192,9 +120,6 @@ nouveau_bo_kalloc(struct nouveau_bo_priv *nvbo, struct nouveau_channel *chan)
 	if (nvbo->handle || (nvbo->flags & NOUVEAU_BO_PIN))
 		return 0;
 
-	if (!nvdev->mm_enabled)
-		return nouveau_bo_kalloc_nomm(nvbo);
-
 	req.channel_hint = chan ? chan->id : 0;
 	req.align = nvbo->align;
 
@@ -227,21 +152,6 @@ nouveau_bo_kalloc(struct nouveau_bo_priv *nvbo, struct nouveau_channel *chan)
 }
 
 static int
-nouveau_bo_kmap_nomm(struct nouveau_bo_priv *nvbo)
-{
-	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
-	int ret;
-
-	ret = drmMap(nvdev->fd, nvbo->handle, nvbo->size, &nvbo->map);
-	if (ret) {
-		nvbo->map = NULL;
-		return ret;
-	}
-
-	return 0;
-}
-
-static int
 nouveau_bo_kmap(struct nouveau_bo_priv *nvbo)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(nvbo->base.device);
@@ -252,9 +162,6 @@ nouveau_bo_kmap(struct nouveau_bo_priv *nvbo)
 	if (!nvbo->map_handle)
 		return -EINVAL;
 
-	if (!nvdev->mm_enabled)
-		return nouveau_bo_kmap_nomm(nvbo);
-
 	nvbo->map = mmap(0, nvbo->size, PROT_READ | PROT_WRITE,
 			 MAP_SHARED, nvdev->fd, nvbo->map_handle);
 	if (nvbo->map == MAP_FAILED) {
@@ -328,7 +235,7 @@ nouveau_bo_user(struct nouveau_device *dev, void *ptr, int size,
 	struct nouveau_bo_priv *nvbo;
 	int ret;
 
-	ret = nouveau_bo_new(dev, 0, 0, size, bo);
+	ret = nouveau_bo_new(dev, NOUVEAU_BO_MAP, 0, size, bo);
 	if (ret)
 		return ret;
 	nvbo = nouveau_bo(*bo);
@@ -339,28 +246,6 @@ nouveau_bo_user(struct nouveau_device *dev, void *ptr, int size,
 }
 
 int
-nouveau_bo_fake(struct nouveau_device *dev, uint64_t offset, uint32_t flags,
-		uint32_t size, void *map, struct nouveau_bo **bo)
-{
-	struct nouveau_bo_priv *nvbo;
-	int ret;
-
-	ret = nouveau_bo_new(dev, flags & ~NOUVEAU_BO_PIN, 0, size, bo);
-	if (ret)
-		return ret;
-	nvbo = nouveau_bo(*bo);
-
-	nvbo->flags = flags | NOUVEAU_BO_PIN;
-	nvbo->domain = (flags & (NOUVEAU_BO_VRAM|NOUVEAU_BO_GART));
-	nvbo->offset = offset;
-	nvbo->size = nvbo->base.size = size;
-	nvbo->map = map;
-	nvbo->base.flags = nvbo->flags;
-	nvbo->base.offset = nvbo->offset;
-	return 0;
-}
-
-int
 nouveau_bo_wrap(struct nouveau_device *dev, uint32_t handle,
 		struct nouveau_bo **bo)
 {
@@ -369,9 +254,6 @@ nouveau_bo_wrap(struct nouveau_device *dev, uint32_t handle,
 	struct nouveau_bo_priv *nvbo;
 	int ret;
 
-	if (!nvdev->mm_enabled)
-		return -ENODEV;
-
 	ret = nouveau_bo_new(dev, 0, 0, 0, bo);
 	if (ret)
 		return ret;
@@ -386,6 +268,7 @@ nouveau_bo_wrap(struct nouveau_device *dev, uint32_t handle,
 	}
 
 	nouveau_bo_info(nvbo, &req);
+	nvbo->base.size = nvbo->size;
 	return 0;
 }
 
@@ -406,18 +289,14 @@ nouveau_bo_handle_get(struct nouveau_bo *bo, uint32_t *handle)
 		if (ret)
 			return ret;
 
-		if (nvdev->mm_enabled) {
-			req.handle = nvbo->handle;
-			ret = ioctl(nvdev->fd, DRM_IOCTL_GEM_FLINK, &req);
-			if (ret) {
-				nouveau_bo_kfree(nvbo);
-				return ret;
-			}
-	 
-			nvbo->global_handle = req.name;
-		} else {
-			nvbo->global_handle = nvbo->offset;
+		req.handle = nvbo->handle;
+		ret = ioctl(nvdev->fd, DRM_IOCTL_GEM_FLINK, &req);
+		if (ret) {
+			nouveau_bo_kfree(nvbo);
+			return ret;
 		}
+
+		nvbo->global_handle = req.name;
 	}
  
 	*handle = nvbo->global_handle;
@@ -433,51 +312,25 @@ nouveau_bo_handle_ref(struct nouveau_device *dev, uint32_t handle,
 	struct drm_gem_open req;
 	int ret;
 
-	if (!nvdev->mm_enabled) {
-		ret = nouveau_bo_new(dev, 0, 0, 0, bo);
-		if (ret)
-			return ret;
-		nvbo = nouveau_bo(*bo);
-
-		nvbo->handle = 0;
-		nvbo->offset =  handle;
-		nvbo->domain = NOUVEAU_BO_VRAM;
-		nvbo->flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_PIN;
-		nvbo->base.offset = nvbo->offset;
-		nvbo->base.flags = nvbo->flags;
-	} else {
-		req.name = handle;
-		ret = ioctl(nvdev->fd, DRM_IOCTL_GEM_OPEN, &req);
-		if (ret) {
-			nouveau_bo_ref(NULL, bo);
-			return ret;
-		}
-
-		ret = nouveau_bo_wrap(dev, req.handle, bo);
-		if (ret) {
-			nouveau_bo_ref(NULL, bo);
-			return ret;
-		}
+	req.name = handle;
+	ret = ioctl(nvdev->fd, DRM_IOCTL_GEM_OPEN, &req);
+	if (ret) {
+		nouveau_bo_ref(NULL, bo);
+		return ret;
+	}
 
-		nvbo = nouveau_bo(*bo);
+	ret = nouveau_bo_wrap(dev, req.handle, bo);
+	if (ret) {
+		nouveau_bo_ref(NULL, bo);
+		return ret;
 	}
 
+	nvbo = nouveau_bo(*bo);
 	nvbo->base.handle = nvbo->handle;
 	return 0;
 } 
 
 static void
-nouveau_bo_del_cb(void *priv)
-{
-	struct nouveau_bo_priv *nvbo = priv;
-
-	nouveau_fence_ref(NULL, &nvbo->fence);
-	nouveau_fence_ref(NULL, &nvbo->wr_fence);
-	nouveau_bo_kfree(nvbo);
-	free(nvbo);
-}
-
-static void
 nouveau_bo_del(struct nouveau_bo **bo)
 {
 	struct nouveau_bo_priv *nvbo;
@@ -496,18 +349,8 @@ nouveau_bo_del(struct nouveau_bo **bo)
 	}
 
 	nouveau_bo_ufree(nvbo);
-
-	if (!nouveau_device(nvbo->base.device)->mm_enabled && nvbo->fence) {
-		nouveau_fence_flush(nvbo->fence->channel);
-		if (nouveau_fence(nvbo->fence)->signalled) {
-			nouveau_bo_del_cb(nvbo);
-		} else {
-			nouveau_fence_signal_cb(nvbo->fence,
-					        nouveau_bo_del_cb, nvbo);
-		}
-	} else {
-		nouveau_bo_del_cb(nvbo);
-	}
+	nouveau_bo_kfree(nvbo);
+	free(nvbo);
 }
 
 int
@@ -527,24 +370,7 @@ nouveau_bo_ref(struct nouveau_bo *ref, struct nouveau_bo **pbo)
 }
 
 static int
-nouveau_bo_wait_nomm(struct nouveau_bo *bo, int cpu_write)
-{
-	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
-	int ret = 0;
-
-	if (cpu_write)
-		ret = nouveau_fence_wait(&nvbo->fence);
-	else
-		ret = nouveau_fence_wait(&nvbo->wr_fence);
-	if (ret)
-		return ret;
-
-	nvbo->write_marker = 0;
-	return 0;
-}
-
-static int
-nouveau_bo_wait(struct nouveau_bo *bo, int cpu_write)
+nouveau_bo_wait(struct nouveau_bo *bo, int cpu_write, int no_wait, int no_block)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
 	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
@@ -560,10 +386,15 @@ nouveau_bo_wait(struct nouveau_bo *bo, int cpu_write)
 		nouveau_pushbuf_flush(nvbo->pending_channel, 0);
 	}
 
-	if (!nvdev->mm_enabled)
-		return nouveau_bo_wait_nomm(bo, cpu_write);
-
 	req.handle = nvbo->handle;
+	req.flags = 0;
+	if (cpu_write)
+		req.flags |= NOUVEAU_GEM_CPU_PREP_WRITE;
+	if (no_wait)
+		req.flags |= NOUVEAU_GEM_CPU_PREP_NOWAIT;
+	if (no_block)
+		req.flags |= NOUVEAU_GEM_CPU_PREP_NOBLOCK;
+
 	do {
 		ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_CPU_PREP,
 				      &req, sizeof(req));
@@ -608,7 +439,8 @@ nouveau_bo_map_range(struct nouveau_bo *bo, uint32_t delta, uint32_t size,
 			return ret;
 
 		if (!(flags & NOUVEAU_BO_NOSYNC)) {
-			ret = nouveau_bo_wait(bo, (flags & NOUVEAU_BO_WR));
+			ret = nouveau_bo_wait(bo, (flags & NOUVEAU_BO_WR),
+					      (flags & NOUVEAU_BO_NOWAIT), 0);
 			if (ret)
 				return ret;
 		}
@@ -633,10 +465,9 @@ nouveau_bo_map(struct nouveau_bo *bo, uint32_t flags)
 void
 nouveau_bo_unmap(struct nouveau_bo *bo)
 {
-	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
 	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
 
-	if (nvdev->mm_enabled && bo->map && !nvbo->sysmem) {
+	if (bo->map && !nvbo->sysmem) {
 		struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
 		struct drm_nouveau_gem_cpu_fini req;
 
@@ -649,95 +480,6 @@ nouveau_bo_unmap(struct nouveau_bo *bo)
 }
 
 int
-nouveau_bo_validate_nomm(struct nouveau_bo_priv *nvbo, uint32_t flags)
-{
-	struct nouveau_bo *new = NULL;
-	uint32_t t_handle, t_domain, t_offset, t_size, t_maph;
-	void *t_map;
-	int ret;
-
-	if ((flags & NOUVEAU_BO_VRAM) && nvbo->domain == NOUVEAU_BO_VRAM)
-		return 0;
-	if ((flags & NOUVEAU_BO_GART) && nvbo->domain == NOUVEAU_BO_GART)
-		return 0;
-	assert(flags & (NOUVEAU_BO_VRAM|NOUVEAU_BO_GART));
-
-	/* Keep tiling info */
-	flags |= (nvbo->flags & (NOUVEAU_BO_TILED|NOUVEAU_BO_ZTILE));
-
-	ret = nouveau_bo_new(nvbo->base.device, flags, 0, nvbo->size, &new);
-	if (ret)
-		return ret;
-
-	ret = nouveau_bo_kalloc(nouveau_bo(new), NULL);
-	if (ret) {
-		nouveau_bo_ref(NULL, &new);
-		return ret;
-	}
-
-	if (nvbo->handle || nvbo->sysmem) {
-	nouveau_bo_kmap(nouveau_bo(new));
-
-	if (!nvbo->base.map) {
-		nouveau_bo_map(&nvbo->base, NOUVEAU_BO_RD);
-		memcpy(nouveau_bo(new)->map, nvbo->base.map, nvbo->base.size);
-		nouveau_bo_unmap(&nvbo->base);
-	} else {
-		memcpy(nouveau_bo(new)->map, nvbo->base.map, nvbo->base.size);
-	}
-	}
-
-	t_handle = nvbo->handle;
-	t_maph = nvbo->map_handle;
-	t_domain = nvbo->domain;
-	t_offset = nvbo->offset;
-	t_size = nvbo->size;
-	t_map = nvbo->map;
-
-	nvbo->handle = nouveau_bo(new)->handle;
-	nvbo->map_handle = nouveau_bo(new)->map_handle;
-	nvbo->domain = nouveau_bo(new)->domain;
-	nvbo->offset = nouveau_bo(new)->offset;
-	nvbo->size = nouveau_bo(new)->size;
-	nvbo->map = nouveau_bo(new)->map;
-
-	nouveau_bo(new)->handle = t_handle;
-	nouveau_bo(new)->map_handle = t_maph;
-	nouveau_bo(new)->domain = t_domain;
-	nouveau_bo(new)->offset = t_offset;
-	nouveau_bo(new)->size = t_size;
-	nouveau_bo(new)->map = t_map;
-
-	nouveau_bo_ref(NULL, &new);
-
-	return 0;
-}
-
-static int
-nouveau_bo_pin_nomm(struct nouveau_bo *bo, uint32_t flags)
-{
-	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
-	int ret;
-
-	if (!nvbo->handle) {
-		if (!(flags & (NOUVEAU_BO_VRAM | NOUVEAU_BO_GART)))
-			return -EINVAL;
-
-		ret = nouveau_bo_validate_nomm(nvbo, flags & ~NOUVEAU_BO_PIN);
-		if (ret)
-			return ret;
-	}
-
-	nvbo->pinned = 1;
-
-	/* Fill in public nouveau_bo members */
-	bo->flags = nvbo->domain;
-	bo->offset = nvbo->offset;
-
-	return 0;
-}
-
-int
 nouveau_bo_pin(struct nouveau_bo *bo, uint32_t flags)
 {
 	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
@@ -748,9 +490,6 @@ nouveau_bo_pin(struct nouveau_bo *bo, uint32_t flags)
 	if (nvbo->pinned)
 		return 0;
 
-	if (!nvdev->mm_enabled)
-		return nouveau_bo_pin_nomm(bo, flags);
-
 	/* Ensure we have a kernel object... */
 	if (!nvbo->flags) {
 		if (!(flags & (NOUVEAU_BO_VRAM | NOUVEAU_BO_GART)))
@@ -801,80 +540,16 @@ nouveau_bo_unpin(struct nouveau_bo *bo)
 	if (!nvbo->pinned)
 		return;
 
-	if (nvdev->mm_enabled) {
-		req.handle = nvbo->handle;
-		drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_UNPIN,
-				&req, sizeof(req));
-	}
+	req.handle = nvbo->handle;
+	drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_UNPIN, &req, sizeof(req));
 
 	nvbo->pinned = bo->offset = bo->flags = 0;
 }
 
 int
-nouveau_bo_tile(struct nouveau_bo *bo, uint32_t flags, uint32_t delta,
-		uint32_t size)
-{
-	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
-	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
-	uint32_t kern_flags = 0;
-	int ret = 0;
-
-	if (flags & NOUVEAU_BO_TILED) {
-		kern_flags |= NOUVEAU_MEM_TILE;
-		if (flags & NOUVEAU_BO_ZTILE)
-			kern_flags |= NOUVEAU_MEM_TILE_ZETA;
-	}
-
-	if (nvdev->mm_enabled) {
-		struct drm_nouveau_gem_tile req;
-
-		req.handle = nvbo->handle;
-		req.delta = delta;
-		req.size = size;
-		req.flags = kern_flags;
-		ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_TILE,
-				      &req, sizeof(req));
-	} else {
-		struct drm_nouveau_mem_tile req;
-
-		req.offset = nvbo->offset;
-		req.delta = delta;
-		req.size = size;
-		req.flags = kern_flags;
-
-		if (flags & NOUVEAU_BO_VRAM)
-			req.flags |= NOUVEAU_MEM_FB;
-		if (flags & NOUVEAU_BO_GART)
-			req.flags |= NOUVEAU_MEM_AGP;
-
-		ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_MEM_TILE,
-				      &req, sizeof(req));
-	}
-
-	return 0;
-}
-
-int
 nouveau_bo_busy(struct nouveau_bo *bo, uint32_t access)
 {
-	struct nouveau_device_priv *nvdev = nouveau_device(bo->device);
-	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
-
-	if (!nvdev->mm_enabled) {
-		struct nouveau_fence *fence;
-
-		if (nvbo->pending && (nvbo->pending->write_domains ||
-				      (access & NOUVEAU_BO_WR)))
-			return 1;
-
-		if (access & NOUVEAU_BO_WR)
-			fence = nvbo->fence;
-		else
-			fence = nvbo->wr_fence;
-		return !nouveau_fence(fence)->signalled;
-	}
-
-	return 1;
+	return nouveau_bo_wait(bo, (access & NOUVEAU_BO_WR), 1, 1);
 }
 
 struct drm_nouveau_gem_pushbuf_bo *
@@ -904,12 +579,12 @@ nouveau_bo_emit_buffer(struct nouveau_channel *chan, struct nouveau_bo *bo)
 			nvbo->sysmem = sysmem_tmp;
 
 			memcpy(bo->map, nvbo->sysmem, nvbo->base.size);
-			nouveau_bo_unmap(bo);
 			nouveau_bo_ufree(nvbo);
+			nouveau_bo_unmap(bo);
 		}
 	}
 
-	if (nvpb->nr_buffers >= NOUVEAU_PUSHBUF_MAX_BUFFERS)
+	if (nvpb->nr_buffers >= NOUVEAU_GEM_MAX_BUFFERS)
 		return NULL;
 	pbbo = nvpb->buffers + nvpb->nr_buffers++;
 	nvbo->pending = pbbo;
diff --git a/libdrm/nouveau/nouveau_bo.h b/libdrm/nouveau/nouveau_bo.h
index 9b1feff..97ad2d7 100644
--- a/libdrm/nouveau/nouveau_bo.h
+++ b/libdrm/nouveau/nouveau_bo.h
@@ -72,10 +72,6 @@ nouveau_bo_user(struct nouveau_device *, void *ptr, int size,
 		struct nouveau_bo **);
 
 int
-nouveau_bo_fake(struct nouveau_device *dev, uint64_t offset, uint32_t flags,
-		uint32_t size, void *map, struct nouveau_bo **);
-
-int
 nouveau_bo_wrap(struct nouveau_device *, uint32_t handle, struct nouveau_bo **);
 
 int
@@ -108,10 +104,6 @@ void
 nouveau_bo_unpin(struct nouveau_bo *);
 
 int
-nouveau_bo_tile(struct nouveau_bo *, uint32_t flags, uint32_t delta,
-		uint32_t size);
-
-int
 nouveau_bo_busy(struct nouveau_bo *, uint32_t access);
 
 #endif
diff --git a/libdrm/nouveau/nouveau_channel.c b/libdrm/nouveau/nouveau_channel.c
index 5de27dc..674c5c3 100644
--- a/libdrm/nouveau/nouveau_channel.c
+++ b/libdrm/nouveau/nouveau_channel.c
@@ -74,8 +74,10 @@ nouveau_channel_alloc(struct nouveau_device *dev, uint32_t fb_ctxdma,
 		nvchan->base.subc[i].gr = &gr->base;
 	}
 
-	ret = drmMap(nvdev->fd, nvchan->drm.notifier, nvchan->drm.notifier_size,
-		     (drmAddressPtr)&nvchan->notifier_block);
+	ret = nouveau_bo_wrap(dev, nvchan->drm.notifier_handle,
+			      &nvchan->notifier_bo);
+	if (!ret)
+		ret = nouveau_bo_map(nvchan->notifier_bo, NOUVEAU_BO_RDWR);
 	if (ret) {
 		nouveau_channel_free((void *)&nvchan);
 		return ret;
@@ -88,49 +90,8 @@ nouveau_channel_alloc(struct nouveau_device *dev, uint32_t fb_ctxdma,
 		return ret;
 	}
 
-	if (!nvdev->mm_enabled) {
-		ret = drmMap(nvdev->fd, nvchan->drm.ctrl, nvchan->drm.ctrl_size,
-			     (void*)&nvchan->user);
-		if (ret) {
-			nouveau_channel_free((void *)&nvchan);
-			return ret;
-		}
-		nvchan->put     = &nvchan->user[0x40/4];
-		nvchan->get     = &nvchan->user[0x44/4];
-		nvchan->ref_cnt = &nvchan->user[0x48/4];
-
-		ret = drmMap(nvdev->fd, nvchan->drm.cmdbuf,
-			     nvchan->drm.cmdbuf_size, (void*)&nvchan->pushbuf);
-		if (ret) {
-			nouveau_channel_free((void *)&nvchan);
-			return ret;
-		}
-
-		nouveau_dma_channel_init(&nvchan->base);
-	}
-
 	nouveau_pushbuf_init(&nvchan->base);
 
-	if (!nvdev->mm_enabled && dev->chipset < 0x10) {
-		ret = nouveau_grobj_alloc(&nvchan->base, 0xbeef3904, 0x5039,
-					  &nvchan->fence_grobj);
-		if (ret) {
-			nouveau_channel_free((void *)&nvchan);
-			return ret;
-		}
-
-		ret = nouveau_notifier_alloc(&nvchan->base, 0xbeef3905, 1,
-					     &nvchan->fence_ntfy);
-		if (ret) {
-			nouveau_channel_free((void *)&nvchan);
-			return ret;
-		}
-
-		BEGIN_RING(&nvchan->base, nvchan->fence_grobj, 0x0180, 1);
-		OUT_RING  (&nvchan->base, nvchan->fence_ntfy->handle);
-		nvchan->fence_grobj->bound = NOUVEAU_GROBJ_BOUND_EXPLICIT;
-	}
-
 	*chan = &nvchan->base;
 	return 0;
 }
@@ -147,28 +108,15 @@ nouveau_channel_free(struct nouveau_channel **chan)
 	nvchan = nouveau_channel(*chan);
 	*chan = NULL;
 	nvdev = nouveau_device(nvchan->base.device);
-	
-	FIRE_RING(&nvchan->base);
-
-	if (!nvdev->mm_enabled) {
-		struct nouveau_fence *fence = NULL;
 
-		/* Make sure all buffer objects on delayed delete queue
-		 * actually get freed.
-		 */
-		nouveau_fence_new(&nvchan->base, &fence);
-		nouveau_fence_emit(fence);
-		nouveau_fence_wait(&fence);
-	}
+	FIRE_RING(&nvchan->base);
 
-	if (nvchan->notifier_block)
-		drmUnmap(nvchan->notifier_block, nvchan->drm.notifier_size);
+	nouveau_bo_unmap(nvchan->notifier_bo);
+	nouveau_bo_ref(NULL, &nvchan->notifier_bo);
 
 	nouveau_grobj_free(&nvchan->base.vram);
 	nouveau_grobj_free(&nvchan->base.gart);
 	nouveau_grobj_free(&nvchan->base.nullobj);
-	nouveau_grobj_free(&nvchan->fence_grobj);
-	nouveau_notifier_free(&nvchan->fence_ntfy);
 
 	cf.channel = nvchan->drm.channel;
 	drmCommandWrite(nvdev->fd, DRM_NOUVEAU_CHANNEL_FREE, &cf, sizeof(cf));
diff --git a/libdrm/nouveau/nouveau_class.h b/libdrm/nouveau/nouveau_class.h
index 3df3d7b..4d1c509 100644
--- a/libdrm/nouveau/nouveau_class.h
+++ b/libdrm/nouveau/nouveau_class.h
@@ -6564,6 +6564,14 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define    NV40TCL_BLEND_FUNC_DST_ALPHA_CONSTANT_ALPHA					0x80030000
 #define    NV40TCL_BLEND_FUNC_DST_ALPHA_ONE_MINUS_CONSTANT_ALPHA			0x80040000
 #define  NV40TCL_BLEND_COLOR								0x0000031c
+#define   NV40TCL_BLEND_COLOR_B_SHIFT							0
+#define   NV40TCL_BLEND_COLOR_B_MASK							0x000000ff
+#define   NV40TCL_BLEND_COLOR_G_SHIFT							8
+#define   NV40TCL_BLEND_COLOR_G_MASK							0x0000ff00
+#define   NV40TCL_BLEND_COLOR_R_SHIFT							16
+#define   NV40TCL_BLEND_COLOR_R_MASK							0x00ff0000
+#define   NV40TCL_BLEND_COLOR_A_SHIFT							24
+#define   NV40TCL_BLEND_COLOR_A_MASK							0xff000000
 #define  NV40TCL_BLEND_EQUATION								0x00000320
 #define   NV40TCL_BLEND_EQUATION_RGB_SHIFT						0
 #define   NV40TCL_BLEND_EQUATION_RGB_MASK						0x0000ffff
@@ -6778,6 +6786,25 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV40TCL_VTX_ATTR_3I_Z__SIZE							0x00000010
 #define   NV40TCL_VTX_ATTR_3I_Z_Z_SHIFT							0
 #define   NV40TCL_VTX_ATTR_3I_Z_Z_MASK							0x0000ffff
+#define  NV40TCL_TEX_FILTER_OPTIMIZATION						0x00000b00
+#define   NV40TCL_TEX_FILTER_OPTIMIZATION_TRILINEAR_SHIFT				0
+#define   NV40TCL_TEX_FILTER_OPTIMIZATION_TRILINEAR_MASK				0x0000001f
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_TRILINEAR_OFF				0x00000000
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_TRILINEAR_HIGH_QUALITY			0x00000004
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_TRILINEAR_QUALITY				0x00000006
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_TRILINEAR_PERFORMANCE			0x00000008
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_TRILINEAR_HIGH_PERFORMANCE			0x00000018
+#define   NV40TCL_TEX_FILTER_OPTIMIZATION_ANISO_SAMPLE_SHIFT				6
+#define   NV40TCL_TEX_FILTER_OPTIMIZATION_ANISO_SAMPLE_MASK				0x000001c0
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_ANISO_SAMPLE_OFF				0x00000000
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_ANISO_SAMPLE_HIGH_QUALITY			0x000000c0
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_ANISO_SAMPLE_QUALITY				0x000001c0
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_ANISO_SAMPLE_PERFORMANCE			0x00000140
+#define   NV40TCL_TEX_FILTER_OPTIMIZATION_UNKNOWN_SHIFT					10
+#define   NV40TCL_TEX_FILTER_OPTIMIZATION_UNKNOWN_MASK					0x00007c00
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_UNKNOWN_OFF					0x00000000
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_UNKNOWN_PARTIAL				0x00002c00
+#define    NV40TCL_TEX_FILTER_OPTIMIZATION_UNKNOWN_FULL					0x00007c00
 #define  NV40TCL_UNK0B40(x)								(0x00000b40+((x)*4))
 #define  NV40TCL_UNK0B40__SIZE								0x00000008
 #define  NV40TCL_VP_UPLOAD_INST(x)							(0x00000b80+((x)*4))
@@ -6951,7 +6978,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV40TCL_TEX_WRAP(x)								(0x00001a08+((x)*32))
 #define  NV40TCL_TEX_WRAP__SIZE								0x00000010
 #define   NV40TCL_TEX_WRAP_S_SHIFT							0
-#define   NV40TCL_TEX_WRAP_S_MASK							0x000000ff
+#define   NV40TCL_TEX_WRAP_S_MASK							0x0000000f
 #define    NV40TCL_TEX_WRAP_S_REPEAT							0x00000001
 #define    NV40TCL_TEX_WRAP_S_MIRRORED_REPEAT						0x00000002
 #define    NV40TCL_TEX_WRAP_S_CLAMP_TO_EDGE						0x00000003
@@ -6960,6 +6987,12 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define    NV40TCL_TEX_WRAP_S_MIRROR_CLAMP_TO_EDGE					0x00000006
 #define    NV40TCL_TEX_WRAP_S_MIRROR_CLAMP_TO_BORDER					0x00000007
 #define    NV40TCL_TEX_WRAP_S_MIRROR_CLAMP						0x00000008
+#define   NV40TCL_TEX_WRAP_ANISO_MIP_FILTER_OPTIMIZATION_SHIFT				4
+#define   NV40TCL_TEX_WRAP_ANISO_MIP_FILTER_OPTIMIZATION_MASK				0x00000070
+#define    NV40TCL_TEX_WRAP_ANISO_MIP_FILTER_OPTIMIZATION_OFF				0x00000000
+#define    NV40TCL_TEX_WRAP_ANISO_MIP_FILTER_OPTIMIZATION_QUALITY			0x00000020
+#define    NV40TCL_TEX_WRAP_ANISO_MIP_FILTER_OPTIMIZATION_PERFORMANCE			0x00000030
+#define    NV40TCL_TEX_WRAP_ANISO_MIP_FILTER_OPTIMIZATION_HIGH_PERFORMANCE		0x00000070
 #define   NV40TCL_TEX_WRAP_T_SHIFT							8
 #define   NV40TCL_TEX_WRAP_T_MASK							0x00000f00
 #define    NV40TCL_TEX_WRAP_T_REPEAT							0x00000100
@@ -6973,7 +7006,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define   NV40TCL_TEX_WRAP_EXPAND_NORMAL_SHIFT						12
 #define   NV40TCL_TEX_WRAP_EXPAND_NORMAL_MASK						0x0000f000
 #define   NV40TCL_TEX_WRAP_R_SHIFT							16
-#define   NV40TCL_TEX_WRAP_R_MASK							0x00ff0000
+#define   NV40TCL_TEX_WRAP_R_MASK							0x000f0000
 #define    NV40TCL_TEX_WRAP_R_REPEAT							0x00010000
 #define    NV40TCL_TEX_WRAP_R_MIRRORED_REPEAT						0x00020000
 #define    NV40TCL_TEX_WRAP_R_CLAMP_TO_EDGE						0x00030000
@@ -6982,6 +7015,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define    NV40TCL_TEX_WRAP_R_MIRROR_CLAMP_TO_EDGE					0x00060000
 #define    NV40TCL_TEX_WRAP_R_MIRROR_CLAMP_TO_BORDER					0x00070000
 #define    NV40TCL_TEX_WRAP_R_MIRROR_CLAMP						0x00080000
+#define   NV40TCL_TEX_WRAP_GAMMA_DECREASE_FILTER_SHIFT					20
+#define   NV40TCL_TEX_WRAP_GAMMA_DECREASE_FILTER_MASK					0x00f00000
+#define    NV40TCL_TEX_WRAP_GAMMA_DECREASE_FILTER_NONE					0x00000000
+#define    NV40TCL_TEX_WRAP_GAMMA_DECREASE_FILTER_RED					0x00100000
+#define    NV40TCL_TEX_WRAP_GAMMA_DECREASE_FILTER_GREEN					0x00200000
+#define    NV40TCL_TEX_WRAP_GAMMA_DECREASE_FILTER_BLUE					0x00400000
+#define    NV40TCL_TEX_WRAP_GAMMA_DECREASE_FILTER_ALL					0x00f00000
 #define   NV40TCL_TEX_WRAP_RCOMP_SHIFT							28
 #define   NV40TCL_TEX_WRAP_RCOMP_MASK							0xf0000000
 #define    NV40TCL_TEX_WRAP_RCOMP_NEVER							0x00000000
@@ -7150,22 +7190,74 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV50_2D_DMA_IN_MEMORY1								0x00000188
 #define  NV50_2D_DMA_IN_MEMORY2								0x0000018c
 #define  NV50_2D_DST_FORMAT								0x00000200
-#define   NV50_2D_DST_FORMAT_32BPP							0x000000cf
-#define   NV50_2D_DST_FORMAT_24BPP							0x000000e6
-#define   NV50_2D_DST_FORMAT_16BPP							0x000000e8
-#define   NV50_2D_DST_FORMAT_8BPP							0x000000f3
-#define   NV50_2D_DST_FORMAT_15BPP							0x000000f8
+#define   NV50_2D_DST_FORMAT_R32G32B32A32_FLOAT						0x000000c0
+#define   NV50_2D_DST_FORMAT_R32G32B32_FLOAT						0x000000c3
+#define   NV50_2D_DST_FORMAT_R16G16B16A16_UNORM						0x000000c6
+#define   NV50_2D_DST_FORMAT_R16G16B16A16_SNORM						0x000000c7
+#define   NV50_2D_DST_FORMAT_R16G16B16A16_FLOAT						0x000000ca
+#define   NV50_2D_DST_FORMAT_R32G32_FLOAT						0x000000cb
+#define   NV50_2D_DST_FORMAT_R16G16B16X16_FLOAT						0x000000ce
+#define   NV50_2D_DST_FORMAT_A8R8G8B8_UNORM						0x000000cf
+#define   NV50_2D_DST_FORMAT_A2B10G10R10_UNORM						0x000000d1
+#define   NV50_2D_DST_FORMAT_A8B8G8R8_UNORM						0x000000d6
+#define   NV50_2D_DST_FORMAT_A8B8G8R8_SNORM						0x000000d7
+#define   NV50_2D_DST_FORMAT_R16G16_UNORM						0x000000da
+#define   NV50_2D_DST_FORMAT_R16G16_SNORM						0x000000db
+#define   NV50_2D_DST_FORMAT_R16G16_FLOAT						0x000000de
+#define   NV50_2D_DST_FORMAT_A2R10G10B10_UNORM						0x000000df
+#define   NV50_2D_DST_FORMAT_B10G11R11_FLOAT						0x000000e0
+#define   NV50_2D_DST_FORMAT_R32_FLOAT							0x000000e5
+#define   NV50_2D_DST_FORMAT_X8R8G8B8_UNORM						0x000000e6
+#define   NV50_2D_DST_FORMAT_R5G6B5_UNORM						0x000000e8
+#define   NV50_2D_DST_FORMAT_R16_FLOAT							0x000000e9
+#define   NV50_2D_DST_FORMAT_R8G8_UNORM							0x000000ea
+#define   NV50_2D_DST_FORMAT_R8G8_SNORM							0x000000eb
+#define   NV50_2D_DST_FORMAT_R16_UNORM							0x000000ee
+#define   NV50_2D_DST_FORMAT_R16_SNORM							0x000000ef
+#define   NV50_2D_DST_FORMAT_R8_UNORM							0x000000f3
+#define   NV50_2D_DST_FORMAT_R32_BOOLEAN						0x000000f6
+#define   NV50_2D_DST_FORMAT_A8_UNORM							0x000000f7
+#define   NV50_2D_DST_FORMAT_X1B5G5R5_UNORM						0x000000f8
+#define   NV50_2D_DST_FORMAT_X8B8G8R8_UNORM						0x000000f9
+#define  NV50_2D_DST_LINEAR								0x00000204
+#define  NV50_2D_DST_TILE_MODE								0x00000208
 #define  NV50_2D_DST_PITCH								0x00000214
 #define  NV50_2D_DST_WIDTH								0x00000218
 #define  NV50_2D_DST_HEIGHT								0x0000021c
 #define  NV50_2D_DST_ADDRESS_HIGH							0x00000220
 #define  NV50_2D_DST_ADDRESS_LOW							0x00000224
 #define  NV50_2D_SRC_FORMAT								0x00000230
-#define   NV50_2D_SRC_FORMAT_32BPP							0x000000cf
-#define   NV50_2D_SRC_FORMAT_24BPP							0x000000e6
-#define   NV50_2D_SRC_FORMAT_16BPP							0x000000e8
-#define   NV50_2D_SRC_FORMAT_8BPP							0x000000f3
-#define   NV50_2D_SRC_FORMAT_15BPP							0x000000f8
+#define   NV50_2D_SRC_FORMAT_R32G32B32A32_FLOAT						0x000000c0
+#define   NV50_2D_SRC_FORMAT_R32G32B32_FLOAT						0x000000c3
+#define   NV50_2D_SRC_FORMAT_R16G16B16A16_UNORM						0x000000c6
+#define   NV50_2D_SRC_FORMAT_R16G16B16A16_SNORM						0x000000c7
+#define   NV50_2D_SRC_FORMAT_R16G16B16A16_FLOAT						0x000000ca
+#define   NV50_2D_SRC_FORMAT_R32G32_FLOAT						0x000000cb
+#define   NV50_2D_SRC_FORMAT_R16G16B16X16_FLOAT						0x000000ce
+#define   NV50_2D_SRC_FORMAT_A8R8G8B8_UNORM						0x000000cf
+#define   NV50_2D_SRC_FORMAT_A2B10G10R10_UNORM						0x000000d1
+#define   NV50_2D_SRC_FORMAT_A8B8G8R8_UNORM						0x000000d6
+#define   NV50_2D_SRC_FORMAT_A8B8G8R8_SNORM						0x000000d7
+#define   NV50_2D_SRC_FORMAT_R16G16_UNORM						0x000000da
+#define   NV50_2D_SRC_FORMAT_R16G16_SNORM						0x000000db
+#define   NV50_2D_SRC_FORMAT_R16G16_FLOAT						0x000000de
+#define   NV50_2D_SRC_FORMAT_A2R10G10B10_UNORM						0x000000df
+#define   NV50_2D_SRC_FORMAT_B10G11R11_FLOAT						0x000000e0
+#define   NV50_2D_SRC_FORMAT_R32_FLOAT							0x000000e5
+#define   NV50_2D_SRC_FORMAT_X8R8G8B8_UNORM						0x000000e6
+#define   NV50_2D_SRC_FORMAT_R5G6B5_UNORM						0x000000e8
+#define   NV50_2D_SRC_FORMAT_R16_FLOAT							0x000000e9
+#define   NV50_2D_SRC_FORMAT_R8G8_UNORM							0x000000ea
+#define   NV50_2D_SRC_FORMAT_R8G8_SNORM							0x000000eb
+#define   NV50_2D_SRC_FORMAT_R16_UNORM							0x000000ee
+#define   NV50_2D_SRC_FORMAT_R16_SNORM							0x000000ef
+#define   NV50_2D_SRC_FORMAT_R8_UNORM							0x000000f3
+#define   NV50_2D_SRC_FORMAT_R32_BOOLEAN						0x000000f6
+#define   NV50_2D_SRC_FORMAT_A8_UNORM							0x000000f7
+#define   NV50_2D_SRC_FORMAT_X1B5G5R5_UNORM						0x000000f8
+#define   NV50_2D_SRC_FORMAT_X8B8G8R8_UNORM						0x000000f9
+#define  NV50_2D_SRC_LINEAR								0x00000234
+#define  NV50_2D_SRC_TILE_MODE								0x00000238
 #define  NV50_2D_SRC_PITCH								0x00000244
 #define  NV50_2D_SRC_WIDTH								0x00000248
 #define  NV50_2D_SRC_HEIGHT								0x0000024c
@@ -7193,11 +7285,35 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV50_2D_PATTERN_BITMAP(x)							(0x000002f8+((x)*4))
 #define  NV50_2D_PATTERN_BITMAP__SIZE							0x00000002
 #define  NV50_2D_RECT_FORMAT								0x00000584
-#define   NV50_2D_RECT_FORMAT_32BPP							0x000000cf
-#define   NV50_2D_RECT_FORMAT_24BPP							0x000000e6
-#define   NV50_2D_RECT_FORMAT_16BPP							0x000000e8
-#define   NV50_2D_RECT_FORMAT_8BPP							0x000000f3
-#define   NV50_2D_RECT_FORMAT_15BPP							0x000000f8
+#define   NV50_2D_RECT_FORMAT_R32G32B32A32_FLOAT					0x000000c0
+#define   NV50_2D_RECT_FORMAT_R32G32B32_FLOAT						0x000000c3
+#define   NV50_2D_RECT_FORMAT_R16G16B16A16_UNORM					0x000000c6
+#define   NV50_2D_RECT_FORMAT_R16G16B16A16_SNORM					0x000000c7
+#define   NV50_2D_RECT_FORMAT_R16G16B16A16_FLOAT					0x000000ca
+#define   NV50_2D_RECT_FORMAT_R32G32_FLOAT						0x000000cb
+#define   NV50_2D_RECT_FORMAT_R16G16B16X16_FLOAT					0x000000ce
+#define   NV50_2D_RECT_FORMAT_A8R8G8B8_UNORM						0x000000cf
+#define   NV50_2D_RECT_FORMAT_A2B10G10R10_UNORM						0x000000d1
+#define   NV50_2D_RECT_FORMAT_A8B8G8R8_UNORM						0x000000d6
+#define   NV50_2D_RECT_FORMAT_A8B8G8R8_SNORM						0x000000d7
+#define   NV50_2D_RECT_FORMAT_R16G16_UNORM						0x000000da
+#define   NV50_2D_RECT_FORMAT_R16G16_SNORM						0x000000db
+#define   NV50_2D_RECT_FORMAT_R16G16_FLOAT						0x000000de
+#define   NV50_2D_RECT_FORMAT_A2R10G10B10_UNORM						0x000000df
+#define   NV50_2D_RECT_FORMAT_B10G11R11_FLOAT						0x000000e0
+#define   NV50_2D_RECT_FORMAT_R32_FLOAT							0x000000e5
+#define   NV50_2D_RECT_FORMAT_X8R8G8B8_UNORM						0x000000e6
+#define   NV50_2D_RECT_FORMAT_R5G6B5_UNORM						0x000000e8
+#define   NV50_2D_RECT_FORMAT_R16_FLOAT							0x000000e9
+#define   NV50_2D_RECT_FORMAT_R8G8_UNORM						0x000000ea
+#define   NV50_2D_RECT_FORMAT_R8G8_SNORM						0x000000eb
+#define   NV50_2D_RECT_FORMAT_R16_UNORM							0x000000ee
+#define   NV50_2D_RECT_FORMAT_R16_SNORM							0x000000ef
+#define   NV50_2D_RECT_FORMAT_R8_UNORM							0x000000f3
+#define   NV50_2D_RECT_FORMAT_R32_BOOLEAN						0x000000f6
+#define   NV50_2D_RECT_FORMAT_A8_UNORM							0x000000f7
+#define   NV50_2D_RECT_FORMAT_X1B5G5R5_UNORM						0x000000f8
+#define   NV50_2D_RECT_FORMAT_X8B8G8R8_UNORM						0x000000f9
 #define  NV50_2D_RECT_COLOR								0x00000588
 #define  NV50_2D_RECT_X1								0x00000600
 #define  NV50_2D_RECT_Y1								0x00000604
@@ -7205,11 +7321,35 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV50_2D_RECT_Y2								0x0000060c
 #define  NV50_2D_SIFC_UNK0800								0x00000800
 #define  NV50_2D_SIFC_FORMAT								0x00000804
-#define   NV50_2D_SIFC_FORMAT_32BPP							0x000000cf
-#define   NV50_2D_SIFC_FORMAT_24BPP							0x000000e6
-#define   NV50_2D_SIFC_FORMAT_16BPP							0x000000e8
-#define   NV50_2D_SIFC_FORMAT_8BPP							0x000000f3
-#define   NV50_2D_SIFC_FORMAT_15BPP							0x000000f8
+#define   NV50_2D_SIFC_FORMAT_R32G32B32A32_FLOAT					0x000000c0
+#define   NV50_2D_SIFC_FORMAT_R32G32B32_FLOAT						0x000000c3
+#define   NV50_2D_SIFC_FORMAT_R16G16B16A16_UNORM					0x000000c6
+#define   NV50_2D_SIFC_FORMAT_R16G16B16A16_SNORM					0x000000c7
+#define   NV50_2D_SIFC_FORMAT_R16G16B16A16_FLOAT					0x000000ca
+#define   NV50_2D_SIFC_FORMAT_R32G32_FLOAT						0x000000cb
+#define   NV50_2D_SIFC_FORMAT_R16G16B16X16_FLOAT					0x000000ce
+#define   NV50_2D_SIFC_FORMAT_A8R8G8B8_UNORM						0x000000cf
+#define   NV50_2D_SIFC_FORMAT_A2B10G10R10_UNORM						0x000000d1
+#define   NV50_2D_SIFC_FORMAT_A8B8G8R8_UNORM						0x000000d6
+#define   NV50_2D_SIFC_FORMAT_A8B8G8R8_SNORM						0x000000d7
+#define   NV50_2D_SIFC_FORMAT_R16G16_UNORM						0x000000da
+#define   NV50_2D_SIFC_FORMAT_R16G16_SNORM						0x000000db
+#define   NV50_2D_SIFC_FORMAT_R16G16_FLOAT						0x000000de
+#define   NV50_2D_SIFC_FORMAT_A2R10G10B10_UNORM						0x000000df
+#define   NV50_2D_SIFC_FORMAT_B10G11R11_FLOAT						0x000000e0
+#define   NV50_2D_SIFC_FORMAT_R32_FLOAT							0x000000e5
+#define   NV50_2D_SIFC_FORMAT_X8R8G8B8_UNORM						0x000000e6
+#define   NV50_2D_SIFC_FORMAT_R5G6B5_UNORM						0x000000e8
+#define   NV50_2D_SIFC_FORMAT_R16_FLOAT							0x000000e9
+#define   NV50_2D_SIFC_FORMAT_R8G8_UNORM						0x000000ea
+#define   NV50_2D_SIFC_FORMAT_R8G8_SNORM						0x000000eb
+#define   NV50_2D_SIFC_FORMAT_R16_UNORM							0x000000ee
+#define   NV50_2D_SIFC_FORMAT_R16_SNORM							0x000000ef
+#define   NV50_2D_SIFC_FORMAT_R8_UNORM							0x000000f3
+#define   NV50_2D_SIFC_FORMAT_R32_BOOLEAN						0x000000f6
+#define   NV50_2D_SIFC_FORMAT_A8_UNORM							0x000000f7
+#define   NV50_2D_SIFC_FORMAT_X1B5G5R5_UNORM						0x000000f8
+#define   NV50_2D_SIFC_FORMAT_X8B8G8R8_UNORM						0x000000f9
 #define  NV50_2D_SIFC_WIDTH								0x00000838
 #define  NV50_2D_SIFC_HEIGHT								0x0000083c
 #define  NV50_2D_SIFC_SCALE_UNK0840							0x00000840
@@ -7231,8 +7371,24 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 #define NV50_MEMORY_TO_MEMORY_FORMAT							0x00005039
 
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_IN						0x00000200
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_TILING_MODE_IN					0x00000204
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_TILING_PITCH_IN					0x00000208
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_TILING_HEIGHT_IN					0x0000020c
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_TILING_POSITION_IN				0x00000218
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_OUT					0x0000021c
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_TILING_MODE_OUT					0x00000220
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_TILING_PITCH_OUT					0x00000224
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_TILING_HEIGHT_OUT					0x00000228
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_TILING_POSITION_OUT				0x00000234
 #define  NV50_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN_HIGH					0x00000238
 #define  NV50_MEMORY_TO_MEMORY_FORMAT_OFFSET_OUT_HIGH					0x0000023c
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN						0x0000030c
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_OFFSET_OUT					0x00000310
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_PITCH_IN						0x00000314
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_PITCH_OUT						0x00000318
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_LINE_LENGTH_IN					0x0000031c
+#define  NV50_MEMORY_TO_MEMORY_FORMAT_LINE_COUNT					0x00000320
 
 
 #define NV50TCL										0x00005097
@@ -7250,13 +7406,37 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV50TCL_RT_ADDRESS_LOW__SIZE							0x00000008
 #define  NV50TCL_RT_FORMAT(x)								(0x00000208+((x)*32))
 #define  NV50TCL_RT_FORMAT__SIZE							0x00000008
-#define   NV50TCL_RT_FORMAT_32BPP							0x000000cf
-#define   NV50TCL_RT_FORMAT_24BPP							0x000000e6
-#define   NV50TCL_RT_FORMAT_16BPP							0x000000e8
-#define   NV50TCL_RT_FORMAT_8BPP							0x000000f3
-#define   NV50TCL_RT_FORMAT_15BPP							0x000000f8
-#define  NV50TCL_RT_TILE_UNK(x)								(0x0000020c+((x)*32))
-#define  NV50TCL_RT_TILE_UNK__SIZE							0x00000008
+#define   NV50TCL_RT_FORMAT_R32G32B32A32_FLOAT						0x000000c0
+#define   NV50TCL_RT_FORMAT_R32G32B32_FLOAT						0x000000c3
+#define   NV50TCL_RT_FORMAT_R16G16B16A16_UNORM						0x000000c6
+#define   NV50TCL_RT_FORMAT_R16G16B16A16_SNORM						0x000000c7
+#define   NV50TCL_RT_FORMAT_R16G16B16A16_FLOAT						0x000000ca
+#define   NV50TCL_RT_FORMAT_R32G32_FLOAT						0x000000cb
+#define   NV50TCL_RT_FORMAT_R16G16B16X16_FLOAT						0x000000ce
+#define   NV50TCL_RT_FORMAT_A8R8G8B8_UNORM						0x000000cf
+#define   NV50TCL_RT_FORMAT_A2B10G10R10_UNORM						0x000000d1
+#define   NV50TCL_RT_FORMAT_A8B8G8R8_UNORM						0x000000d6
+#define   NV50TCL_RT_FORMAT_A8B8G8R8_SNORM						0x000000d7
+#define   NV50TCL_RT_FORMAT_R16G16_UNORM						0x000000da
+#define   NV50TCL_RT_FORMAT_R16G16_SNORM						0x000000db
+#define   NV50TCL_RT_FORMAT_R16G16_FLOAT						0x000000de
+#define   NV50TCL_RT_FORMAT_A2R10G10B10_UNORM						0x000000df
+#define   NV50TCL_RT_FORMAT_B10G11R11_FLOAT						0x000000e0
+#define   NV50TCL_RT_FORMAT_R32_FLOAT							0x000000e5
+#define   NV50TCL_RT_FORMAT_X8R8G8B8_UNORM						0x000000e6
+#define   NV50TCL_RT_FORMAT_R5G6B5_UNORM						0x000000e8
+#define   NV50TCL_RT_FORMAT_R16_FLOAT							0x000000e9
+#define   NV50TCL_RT_FORMAT_R8G8_UNORM							0x000000ea
+#define   NV50TCL_RT_FORMAT_R8G8_SNORM							0x000000eb
+#define   NV50TCL_RT_FORMAT_R16_UNORM							0x000000ee
+#define   NV50TCL_RT_FORMAT_R16_SNORM							0x000000ef
+#define   NV50TCL_RT_FORMAT_R8_UNORM							0x000000f3
+#define   NV50TCL_RT_FORMAT_R32_BOOLEAN							0x000000f6
+#define   NV50TCL_RT_FORMAT_A8_UNORM							0x000000f7
+#define   NV50TCL_RT_FORMAT_X1B5G5R5_UNORM						0x000000f8
+#define   NV50TCL_RT_FORMAT_X8B8G8R8_UNORM						0x000000f9
+#define  NV50TCL_RT_TILE_MODE(x)							(0x0000020c+((x)*32))
+#define  NV50TCL_RT_TILE_MODE__SIZE							0x00000008
 #define  NV50TCL_RT_UNK4(x)								(0x00000210+((x)*32))
 #define  NV50TCL_RT_UNK4__SIZE								0x00000008
 #define  NV50TCL_VTX_ATTR_1F(x)								(0x00000300+((x)*4))
@@ -7313,10 +7493,16 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define   NV50TCL_VTX_ATTR_4NI_1_W_MASK							0xffff0000
 #define  NV50TCL_VERTEX_ARRAY_FORMAT(x)							(0x00000900+((x)*16))
 #define  NV50TCL_VERTEX_ARRAY_FORMAT__SIZE						0x00000010
-#define  NV50TCL_VIEWPORT_UNK0(x)							(0x00000a00+((x)*4))
-#define  NV50TCL_VIEWPORT_UNK0__SIZE							0x00000003
-#define  NV50TCL_VIEWPORT_UNK1(x)							(0x00000a0c+((x)*4))
-#define  NV50TCL_VIEWPORT_UNK1__SIZE							0x00000003
+#define   NV50TCL_VERTEX_ARRAY_FORMAT_STRIDE_SHIFT					0
+#define   NV50TCL_VERTEX_ARRAY_FORMAT_STRIDE_MASK					0x000000ff
+#define  NV50TCL_UNK0904_OFFSET_HIGH(x)							(0x00000904+((x)*16))
+#define  NV50TCL_UNK0904_OFFSET_HIGH__SIZE						0x00000010
+#define  NV50TCL_UNK0904_OFFSET_LOW(x)							(0x00000908+((x)*16))
+#define  NV50TCL_UNK0904_OFFSET_LOW__SIZE						0x00000010
+#define  NV50TCL_VIEWPORT_SCALE(x)							(0x00000a00+((x)*4))
+#define  NV50TCL_VIEWPORT_SCALE__SIZE							0x00000003
+#define  NV50TCL_VIEWPORT_TRANSLATE(x)							(0x00000a0c+((x)*4))
+#define  NV50TCL_VIEWPORT_TRANSLATE__SIZE						0x00000003
 #define  NV50TCL_VIEWPORT_HORIZ								0x00000c00
 #define   NV50TCL_VIEWPORT_HORIZ_X_SHIFT						0
 #define   NV50TCL_VIEWPORT_HORIZ_X_MASK							0x0000ffff
@@ -7339,6 +7525,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV50TCL_CLEAR_COLOR__SIZE							0x00000004
 #define  NV50TCL_CLEAR_DEPTH								0x00000d90
 #define  NV50TCL_CLEAR_STENCIL								0x00000da0
+#define  NV50TCL_STRMOUT_UNK0DA8							0x00000da8
 #define  NV50TCL_POLYGON_MODE_FRONT							0x00000dac
 #define   NV50TCL_POLYGON_MODE_FRONT_POINT						0x00001b00
 #define   NV50TCL_POLYGON_MODE_FRONT_LINE						0x00001b01
@@ -7351,16 +7538,19 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV50TCL_POLYGON_OFFSET_POINT_ENABLE						0x00000dc0
 #define  NV50TCL_POLYGON_OFFSET_LINE_ENABLE						0x00000dc4
 #define  NV50TCL_POLYGON_OFFSET_FILL_ENABLE						0x00000dc8
+#define  NV50TCL_WINDOW_LEFT								0x00000df8
+#define  NV50TCL_WINDOW_BOTTOM								0x00000dfc
+#define  NV50TCL_SCISSOR_ENABLE								0x00000e00
 #define  NV50TCL_SCISSOR_HORIZ								0x00000e04
 #define   NV50TCL_SCISSOR_HORIZ_L_SHIFT							0
 #define   NV50TCL_SCISSOR_HORIZ_L_MASK							0x0000ffff
 #define   NV50TCL_SCISSOR_HORIZ_R_SHIFT							16
 #define   NV50TCL_SCISSOR_HORIZ_R_MASK							0xffff0000
 #define  NV50TCL_SCISSOR_VERT								0x00000e08
-#define   NV50TCL_SCISSOR_VERT_T_SHIFT							0
-#define   NV50TCL_SCISSOR_VERT_T_MASK							0x0000ffff
-#define   NV50TCL_SCISSOR_VERT_B_SHIFT							16
-#define   NV50TCL_SCISSOR_VERT_B_MASK							0xffff0000
+#define   NV50TCL_SCISSOR_VERT_B_SHIFT							0
+#define   NV50TCL_SCISSOR_VERT_B_MASK							0x0000ffff
+#define   NV50TCL_SCISSOR_VERT_T_SHIFT							16
+#define   NV50TCL_SCISSOR_VERT_T_MASK							0xffff0000
 #define  NV50TCL_CB_ADDR								0x00000f00
 #define   NV50TCL_CB_ADDR_ID_SHIFT							8
 #define   NV50TCL_CB_ADDR_ID_MASK							0xffffff00
@@ -7375,16 +7565,40 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV50TCL_GP_ADDRESS_LOW								0x00000f74
 #define  NV50TCL_VP_ADDRESS_HIGH							0x00000f7c
 #define  NV50TCL_VP_ADDRESS_LOW								0x00000f80
+#define  NV50TCL_UNK0F84_ADDRESS_HIGH							0x00000f84
+#define  NV50TCL_UNK0F84_ADDRESS_LOW							0x00000f88
+#define  NV50TCL_DEPTH_BOUNDS(x)							(0x00000f9c+((x)*4))
+#define  NV50TCL_DEPTH_BOUNDS__SIZE							0x00000002
 #define  NV50TCL_FP_ADDRESS_HIGH							0x00000fa4
 #define  NV50TCL_FP_ADDRESS_LOW								0x00000fa8
+#define  NV50TCL_MSAA_MASK(x)								(0x00000fbc+((x)*4))
+#define  NV50TCL_MSAA_MASK__SIZE							0x00000004
 #define  NV50TCL_ZETA_ADDRESS_HIGH							0x00000fe0
 #define  NV50TCL_ZETA_ADDRESS_LOW							0x00000fe4
-#define  NV50TCL_UNKFF4									0x00000ff4
-#define   NV50TCL_UNKFF4_W_SHIFT							16
-#define   NV50TCL_UNKFF4_W_MASK								0xffff0000
-#define  NV50TCL_UNKFF8									0x00000ff8
-#define   NV50TCL_UNKFF8_H_SHIFT							16
-#define   NV50TCL_UNKFF8_H_MASK								0xffff0000
+#define  NV50TCL_ZETA_FORMAT								0x00000fe8
+#define   NV50TCL_ZETA_FORMAT_Z32_FLOAT							0x0000000a
+#define   NV50TCL_ZETA_FORMAT_Z24S8_UNORM						0x00000014
+#define   NV50TCL_ZETA_FORMAT_X8Z24_UNORM						0x00000015
+#define   NV50TCL_ZETA_FORMAT_S8Z24_UNORM						0x00000016
+#define   NV50TCL_ZETA_FORMAT_Z32_FLOAT_X24S8_UNORM					0x00000019
+#define  NV50TCL_ZETA_TILE_MODE								0x00000fec
+#define  NV50TCL_ZETA_UNK								0x00000ff0
+#define  NV50TCL_SCREEN_SCISSOR_HORIZ							0x00000ff4
+#define   NV50TCL_SCREEN_SCISSOR_HORIZ_W_SHIFT						16
+#define   NV50TCL_SCREEN_SCISSOR_HORIZ_W_MASK						0xffff0000
+#define   NV50TCL_SCREEN_SCISSOR_HORIZ_X_SHIFT						0
+#define   NV50TCL_SCREEN_SCISSOR_HORIZ_X_MASK						0x0000ffff
+#define  NV50TCL_SCREEN_SCISSOR_VERT							0x00000ff8
+#define   NV50TCL_SCREEN_SCISSOR_VERT_H_SHIFT						16
+#define   NV50TCL_SCREEN_SCISSOR_VERT_H_MASK						0xffff0000
+#define   NV50TCL_SCREEN_SCISSOR_VERT_Y_SHIFT						0
+#define   NV50TCL_SCREEN_SCISSOR_VERT_Y_MASK						0x0000ffff
+#define  NV50TCL_UNK1080_OFFSET_HIGH(x)							(0x00001080+((x)*8))
+#define  NV50TCL_UNK1080_OFFSET_HIGH__SIZE						0x00000010
+#define  NV50TCL_UNK1080_OFFSET_LOW(x)							(0x00001084+((x)*8))
+#define  NV50TCL_UNK1080_OFFSET_LOW__SIZE						0x00000010
+#define  NV50TCL_ZETA_HORIZ								0x00001228
+#define  NV50TCL_ZETA_VERT								0x0000122c
 #define  NV50TCL_RT_HORIZ(x)								(0x00001240+((x)*8))
 #define  NV50TCL_RT_HORIZ__SIZE								0x00000008
 #define  NV50TCL_RT_VERT(x)								(0x00001244+((x)*8))
@@ -7396,6 +7610,13 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define   NV50TCL_CB_DEF_SET_SIZE_MASK							0x0000ffff
 #define   NV50TCL_CB_DEF_SET_BUFFER_SHIFT						16
 #define   NV50TCL_CB_DEF_SET_BUFFER_MASK						0xffff0000
+#define  NV50TCL_STRMOUT_BUFFERS_CTRL							0x00001294
+#define   NV50TCL_STRMOUT_BUFFERS_CTRL_INTERLEAVED					(1 <<  0)
+#define   NV50TCL_STRMOUT_BUFFERS_CTRL_SEPARATE_SHIFT					4
+#define   NV50TCL_STRMOUT_BUFFERS_CTRL_SEPARATE_MASK					0x000000f0
+#define   NV50TCL_STRMOUT_BUFFERS_CTRL_STRIDE_SHIFT					8
+#define   NV50TCL_STRMOUT_BUFFERS_CTRL_STRIDE_MASK					0x0000ff00
+#define  NV50TCL_FP_RESULT_COUNT							0x00001298
 #define  NV50TCL_DEPTH_TEST_ENABLE							0x000012cc
 #define  NV50TCL_SHADE_MODEL								0x000012d4
 #define   NV50TCL_SHADE_MODEL_FLAT							0x00001d00
@@ -7544,11 +7765,34 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define  NV50TCL_STENCIL_BACK_FUNC_REF							0x00001394
 #define  NV50TCL_STENCIL_BACK_MASK							0x00001398
 #define  NV50TCL_STENCIL_BACK_FUNC_MASK							0x0000139c
+#define  NV50TCL_FRAG_COLOR_CLAMP_EN							0x000013a8
 #define  NV50TCL_LINE_WIDTH								0x000013b0
+#define  NV50TCL_POINT_COORD_REPLACE_MAP(x)						(0x000013c0+((x)*4))
+#define  NV50TCL_POINT_COORD_REPLACE_MAP__SIZE						0x00000008
 #define  NV50TCL_VP_START_ID								0x0000140c
 #define  NV50TCL_GP_START_ID								0x00001410
 #define  NV50TCL_FP_START_ID								0x00001414
+#define  NV50TCL_GP_VERTEX_OUTPUT_COUNT							0x00001420
+#define  NV50TCL_SET_SAMPLER_TEX							0x00001458
+#define   NV50TCL_SET_SAMPLER_TEX_SAMPLER_SHIFT						1
+#define   NV50TCL_SET_SAMPLER_TEX_SAMPLER_MASK						0x000001fe
+#define   NV50TCL_SET_SAMPLER_TEX_TIC_SHIFT						9
+#define   NV50TCL_SET_SAMPLER_TEX_TIC_MASK						0x0001fe00
+#define   NV50TCL_SET_SAMPLER_TEX_VALID							(1 <<  0)
+#define  NV50TCL_STRMOUT_MAP(x)								(0x00001480+((x)*4))
+#define  NV50TCL_STRMOUT_MAP__SIZE							0x00000020
+#define  NV50TCL_VP_CLIP_DISTANCE_ENABLE						0x00001510
+#define   NV50TCL_VP_CLIP_DISTANCE_ENABLE_0						(1 <<  0)
+#define   NV50TCL_VP_CLIP_DISTANCE_ENABLE_1						(1 <<  1)
+#define   NV50TCL_VP_CLIP_DISTANCE_ENABLE_2						(1 <<  2)
+#define   NV50TCL_VP_CLIP_DISTANCE_ENABLE_3						(1 <<  3)
+#define   NV50TCL_VP_CLIP_DISTANCE_ENABLE_4						(1 <<  4)
+#define   NV50TCL_VP_CLIP_DISTANCE_ENABLE_5						(1 <<  5)
 #define  NV50TCL_POINT_SIZE								0x00001518
+#define  NV50TCL_POINT_SPRITE_ENABLE							0x00001520
+#define  NV50TCL_MULTISAMPLE_CTRL							0x0000153c
+#define   NV50TCL_MULTISAMPLE_CTRL_ALPHA_TO_COVERAGE					(1 <<  0)
+#define   NV50TCL_MULTISAMPLE_CTRL_ALPHA_TO_ONE						(1 <<  4)
 #define  NV50TCL_TSC_ADDRESS_HIGH							0x0000155c
 #define  NV50TCL_TSC_ADDRESS_LOW							0x00001560
 #define  NV50TCL_POLYGON_OFFSET_FACTOR							0x0000156c
@@ -7594,6 +7838,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define   NV50TCL_STENCIL_FRONT_FUNC_FUNC_GEQUAL					0x00000206
 #define   NV50TCL_STENCIL_FRONT_FUNC_FUNC_ALWAYS					0x00000207
 #define  NV50TCL_POLYGON_OFFSET_UNITS							0x000015bc
+#define  NV50TCL_MULTISAMPLE_SAMPLES_LOG2						0x000015d0
 #define  NV50TCL_VERTEX_BEGIN								0x000015dc
 #define   NV50TCL_VERTEX_BEGIN_POINTS							0x00000000
 #define   NV50TCL_VERTEX_BEGIN_LINES							0x00000001
@@ -7605,8 +7850,14 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define   NV50TCL_VERTEX_BEGIN_QUADS							0x00000007
 #define   NV50TCL_VERTEX_BEGIN_QUAD_STRIP						0x00000008
 #define   NV50TCL_VERTEX_BEGIN_POLYGON							0x00000009
+#define   NV50TCL_VERTEX_BEGIN_LINES_ADJACENCY						0x0000000a
+#define   NV50TCL_VERTEX_BEGIN_LINE_STRIP_ADJACENCY					0x0000000b
+#define   NV50TCL_VERTEX_BEGIN_TRIANGLES_ADJACENCY					0x0000000c
+#define   NV50TCL_VERTEX_BEGIN_TRIANGLE_STRIP_ADJACENCY					0x0000000d
 #define  NV50TCL_VERTEX_END								0x000015e0
 #define  NV50TCL_VERTEX_DATA								0x00001640
+#define  NV50TCL_PRIM_RESTART_ENABLE							0x00001644
+#define  NV50TCL_PRIM_RESTART_INDEX							0x00001648
 #define  NV50TCL_VP_ATTR_EN_0								0x00001650
 #define   NV50TCL_VP_ATTR_EN_0_7_SHIFT							28
 #define   NV50TCL_VP_ATTR_EN_0_7_MASK							0xf0000000
@@ -7897,29 +8148,87 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define    NV50TCL_VP_ATTR_EN_1_8_XNZW							0x0000000d
 #define    NV50TCL_VP_ATTR_EN_1_8_NYZW							0x0000000e
 #define    NV50TCL_VP_ATTR_EN_1_8_XYZW							0x0000000f
+#define  NV50TCL_POINT_SPRITE_CTRL							0x00001660
 #define  NV50TCL_LINE_STIPPLE_ENABLE							0x0000166c
 #define  NV50TCL_LINE_STIPPLE_PATTERN							0x00001680
+#define  NV50TCL_VERTEX_TWO_SIDE_ENABLE							0x00001688
 #define  NV50TCL_POLYGON_STIPPLE_ENABLE							0x0000168c
-#define  NV50TCL_VP_REG_HPOS								0x000016bc
-#define   NV50TCL_VP_REG_HPOS_X_SHIFT							0
-#define   NV50TCL_VP_REG_HPOS_X_MASK							0x000000ff
-#define   NV50TCL_VP_REG_HPOS_Y_SHIFT							8
-#define   NV50TCL_VP_REG_HPOS_Y_MASK							0x0000ff00
-#define   NV50TCL_VP_REG_HPOS_Z_SHIFT							16
-#define   NV50TCL_VP_REG_HPOS_Z_MASK							0x00ff0000
-#define   NV50TCL_VP_REG_HPOS_W_SHIFT							24
-#define   NV50TCL_VP_REG_HPOS_W_MASK							0xff000000
-#define  NV50TCL_VP_REG_COL0								0x000016c0
-#define   NV50TCL_VP_REG_COL0_X_SHIFT							0
-#define   NV50TCL_VP_REG_COL0_X_MASK							0x000000ff
-#define   NV50TCL_VP_REG_COL0_Y_SHIFT							8
-#define   NV50TCL_VP_REG_COL0_Y_MASK							0x0000ff00
-#define   NV50TCL_VP_REG_COL0_Z_SHIFT							16
-#define   NV50TCL_VP_REG_COL0_Z_MASK							0x00ff0000
-#define   NV50TCL_VP_REG_COL0_W_SHIFT							24
-#define   NV50TCL_VP_REG_COL0_W_MASK							0xff000000
+#define  NV50TCL_SET_PROGRAM_CB								0x00001694
+#define   NV50TCL_SET_PROGRAM_CB_PROGRAM_SHIFT						4
+#define   NV50TCL_SET_PROGRAM_CB_PROGRAM_MASK						0x000000f0
+#define    NV50TCL_SET_PROGRAM_CB_PROGRAM_VERTEX					0x00000000
+#define    NV50TCL_SET_PROGRAM_CB_PROGRAM_GEOMETRY					0x00000020
+#define    NV50TCL_SET_PROGRAM_CB_PROGRAM_FRAGMENT					0x00000030
+#define   NV50TCL_SET_PROGRAM_CB_INDEX_SHIFT						8
+#define   NV50TCL_SET_PROGRAM_CB_INDEX_MASK						0x00000f00
+#define   NV50TCL_SET_PROGRAM_CB_BUFFER_SHIFT						12
+#define   NV50TCL_SET_PROGRAM_CB_BUFFER_MASK						0x000ff000
+#define   NV50TCL_SET_PROGRAM_CB_VALID							(1 <<  0)
+#define  NV50TCL_VP_RESULT_MAP_SIZE							0x000016ac
+#define  NV50TCL_VP_REG_ALLOC_TEMP							0x000016b0
+#define  NV50TCL_VP_REG_ALLOC_RESULT							0x000016b8
+#define  NV50TCL_VP_RESULT_MAP(x)							(0x000016bc+((x)*4))
+#define  NV50TCL_VP_RESULT_MAP__SIZE							0x00000008
+#define   NV50TCL_VP_RESULT_MAP_0_SHIFT							0
+#define   NV50TCL_VP_RESULT_MAP_0_MASK							0x000000ff
+#define   NV50TCL_VP_RESULT_MAP_1_SHIFT							8
+#define   NV50TCL_VP_RESULT_MAP_1_MASK							0x0000ff00
+#define   NV50TCL_VP_RESULT_MAP_2_SHIFT							16
+#define   NV50TCL_VP_RESULT_MAP_2_MASK							0x00ff0000
+#define   NV50TCL_VP_RESULT_MAP_3_SHIFT							24
+#define   NV50TCL_VP_RESULT_MAP_3_MASK							0xff000000
 #define  NV50TCL_POLYGON_STIPPLE_PATTERN(x)						(0x00001700+((x)*4))
 #define  NV50TCL_POLYGON_STIPPLE_PATTERN__SIZE						0x00000020
+#define  NV50TCL_GP_ENABLE								0x00001798
+#define  NV50TCL_GP_REG_ALLOC_TEMP							0x000017a0
+#define  NV50TCL_GP_REG_ALLOC_RESULT							0x000017a8
+#define  NV50TCL_GP_RESULT_MAP_SIZE							0x000017ac
+#define  NV50TCL_GP_OUTPUT_PRIMITIVE_TYPE						0x000017b0
+#define   NV50TCL_GP_OUTPUT_PRIMITIVE_TYPE_POINTS					0x00000001
+#define   NV50TCL_GP_OUTPUT_PRIMITIVE_TYPE_LINE_STRIP					0x00000002
+#define   NV50TCL_GP_OUTPUT_PRIMITIVE_TYPE_TRIANGLE_STRIP				0x00000003
+#define  NV50TCL_RASTERIZE_ENABLE							0x000017b4
+#define  NV50TCL_GP_RESULT_MAP(x)							(0x000017fc+((x)*4))
+#define  NV50TCL_GP_RESULT_MAP__SIZE							0x00000008
+#define   NV50TCL_GP_RESULT_MAP_0_SHIFT							0
+#define   NV50TCL_GP_RESULT_MAP_0_MASK							0x000000ff
+#define   NV50TCL_GP_RESULT_MAP_1_SHIFT							8
+#define   NV50TCL_GP_RESULT_MAP_1_MASK							0x0000ff00
+#define   NV50TCL_GP_RESULT_MAP_2_SHIFT							16
+#define   NV50TCL_GP_RESULT_MAP_2_MASK							0x00ff0000
+#define   NV50TCL_GP_RESULT_MAP_3_SHIFT							24
+#define   NV50TCL_GP_RESULT_MAP_3_MASK							0xff000000
+#define  NV50TCL_MAP_SEMANTIC_0								0x00001904
+#define   NV50TCL_MAP_SEMANTIC_0_FFC0_ID_SHIFT						0
+#define   NV50TCL_MAP_SEMANTIC_0_FFC0_ID_MASK						0x000000ff
+#define   NV50TCL_MAP_SEMANTIC_0_BFC0_ID_SHIFT						8
+#define   NV50TCL_MAP_SEMANTIC_0_BFC0_ID_MASK						0x0000ff00
+#define   NV50TCL_MAP_SEMANTIC_0_COLR_NR_SHIFT						16
+#define   NV50TCL_MAP_SEMANTIC_0_COLR_NR_MASK						0x00ff0000
+#define   NV50TCL_MAP_SEMANTIC_0_CLMP_EN_SHIFT						24
+#define   NV50TCL_MAP_SEMANTIC_0_CLMP_EN_MASK						0xff000000
+#define  NV50TCL_MAP_SEMANTIC_1								0x00001908
+#define   NV50TCL_MAP_SEMANTIC_1_CLIP_LO_SHIFT						0
+#define   NV50TCL_MAP_SEMANTIC_1_CLIP_LO_MASK						0x000000ff
+#define   NV50TCL_MAP_SEMANTIC_1_CLIP_HI_SHIFT						8
+#define   NV50TCL_MAP_SEMANTIC_1_CLIP_HI_MASK						0x0000ff00
+#define   NV50TCL_MAP_SEMANTIC_1_UNKN_02_SHIFT						16
+#define   NV50TCL_MAP_SEMANTIC_1_UNKN_02_MASK						0x00ff0000
+#define   NV50TCL_MAP_SEMANTIC_1_UNKN_03_SHIFT						24
+#define   NV50TCL_MAP_SEMANTIC_1_UNKN_03_MASK						0xff000000
+#define  NV50TCL_MAP_SEMANTIC_2								0x0000190c
+#define   NV50TCL_MAP_SEMANTIC_2_UNKN_00_SHIFT						0
+#define   NV50TCL_MAP_SEMANTIC_2_UNKN_00_MASK						0x000000ff
+#define   NV50TCL_MAP_SEMANTIC_2_UNKN_01_SHIFT						8
+#define   NV50TCL_MAP_SEMANTIC_2_UNKN_01_MASK						0x0000ff00
+#define   NV50TCL_MAP_SEMANTIC_2_UNKN_02_SHIFT						16
+#define   NV50TCL_MAP_SEMANTIC_2_UNKN_02_MASK						0x00ff0000
+#define   NV50TCL_MAP_SEMANTIC_2_UNKN_03_SHIFT						24
+#define   NV50TCL_MAP_SEMANTIC_2_UNKN_03_MASK						0xff000000
+#define  NV50TCL_MAP_SEMANTIC_3								0x00001910
+#define   NV50TCL_MAP_SEMANTIC_3_PTSZ_EN						(1 <<  0)
+#define   NV50TCL_MAP_SEMANTIC_3_PTSZ_ID_SHIFT						4
+#define   NV50TCL_MAP_SEMANTIC_3_PTSZ_ID_MASK						0x00000ff0
 #define  NV50TCL_CULL_FACE_ENABLE							0x00001918
 #define  NV50TCL_FRONT_FACE								0x0000191c
 #define   NV50TCL_FRONT_FACE_CW								0x00000900
@@ -7928,6 +8237,39 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define   NV50TCL_CULL_FACE_FRONT							0x00000404
 #define   NV50TCL_CULL_FACE_BACK							0x00000405
 #define   NV50TCL_CULL_FACE_FRONT_AND_BACK						0x00000408
+#define  NV50TCL_VIEWPORT_TRANSFORM_EN							0x0000192c
+#define  NV50TCL_VIEW_VOLUME_CLIP_CTRL							0x0000193c
+#define  NV50TCL_FP_CTRL_UNK196C							0x0000196c
+#define  NV50TCL_FP_INTERPOLANT_CTRL							0x00001988
+#define   NV50TCL_FP_INTERPOLANT_CTRL_UMASK_SHIFT					24
+#define   NV50TCL_FP_INTERPOLANT_CTRL_UMASK_MASK					0xff000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_NONE					0x00000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_XNNN					0x01000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_NYNN					0x02000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_XYNN					0x03000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_NNZN					0x04000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_XNZN					0x05000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_NYZN					0x06000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_XYZN					0x07000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_NNNW					0x08000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_XNNW					0x09000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_NYNW					0x0a000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_XYNW					0x0b000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_NNZW					0x0c000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_XNZW					0x0d000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_NYZW					0x0e000000
+#define    NV50TCL_FP_INTERPOLANT_CTRL_UMASK_XYZW					0x0f000000
+#define   NV50TCL_FP_INTERPOLANT_CTRL_COUNT_SHIFT					16
+#define   NV50TCL_FP_INTERPOLANT_CTRL_COUNT_MASK					0x00ff0000
+#define   NV50TCL_FP_INTERPOLANT_CTRL_OFFSET_SHIFT					8
+#define   NV50TCL_FP_INTERPOLANT_CTRL_OFFSET_MASK					0x0000ff00
+#define   NV50TCL_FP_INTERPOLANT_CTRL_COUNT_UNK_SHIFT					0
+#define   NV50TCL_FP_INTERPOLANT_CTRL_COUNT_UNK_MASK					0x000000ff
+#define  NV50TCL_FP_REG_ALLOC_TEMP							0x0000198c
+#define  NV50TCL_FP_CTRL_UNK19A8							0x000019a8
+#define   NV50TCL_FP_CTRL_UNK19A8_DEP							(1 << 20)
+#define   NV50TCL_FP_CTRL_UNK19A8_KIL							(1 <<  8)
+#define  NV50TCL_DEPTH_BOUNDS_EN							0x000019bc
 #define  NV50TCL_LOGIC_OP_ENABLE							0x000019c4
 #define  NV50TCL_LOGIC_OP								0x000019c8
 #define   NV50TCL_LOGIC_OP_CLEAR							0x00001500
@@ -7957,6 +8299,43 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define   NV50TCL_COLOR_MASK_B_MASK							0x00000f00
 #define   NV50TCL_COLOR_MASK_A_SHIFT							12
 #define   NV50TCL_COLOR_MASK_A_MASK							0x0000f000
+#define  NV50TCL_STRMOUT_ADDRESS_HIGH(x)						(0x00001a80+((x)*16))
+#define  NV50TCL_STRMOUT_ADDRESS_HIGH__SIZE						0x00000004
+#define  NV50TCL_STRMOUT_ADDRESS_LOW(x)							(0x00001a84+((x)*16))
+#define  NV50TCL_STRMOUT_ADDRESS_LOW__SIZE						0x00000004
+#define  NV50TCL_STRMOUT_NUM_ATTRIBS(x)							(0x00001a88+((x)*16))
+#define  NV50TCL_STRMOUT_NUM_ATTRIBS__SIZE						0x00000004
+#define  NV50TCL_VERTEX_ARRAY_ATTRIB(x)							(0x00001ac0+((x)*4))
+#define  NV50TCL_VERTEX_ARRAY_ATTRIB__SIZE						0x00000010
+#define   NV50TCL_VERTEX_ARRAY_ATTRIB_BUFFER_SHIFT					0
+#define   NV50TCL_VERTEX_ARRAY_ATTRIB_BUFFER_MASK					0x000000ff
+#define   NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_SHIFT					16
+#define   NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_MASK						0x00ff0000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_32_32_32_32					0x00080000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_32_32_32					0x00100000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_32_32					0x00200000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_32						0x00900000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_16_16_16_16					0x00180000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_16_16_16					0x00280000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_16_16					0x00780000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_16						0x00d80000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_8_8_8_8					0x00500000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_8_8_8					0x00980000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_8_8						0x00c00000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_SIZE_8						0x00e80000
+#define   NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_SHIFT					24
+#define   NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_MASK						0xff000000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_FLOAT					0x7e000000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_UNORM					0x24000000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_SNORM					0x12000000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_USCALED					0x5a000000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_SSCALED					0x6c000000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_UINT					0x48000000
+#define    NV50TCL_VERTEX_ARRAY_ATTRIB_TYPE_SINT					0x36000000
+#define  NV50TCL_QUERY_ADDRESS_HIGH							0x00001b00
+#define  NV50TCL_QUERY_ADDRESS_LOW							0x00001b04
+#define  NV50TCL_QUERY_COUNTER								0x00001b08
+#define  NV50TCL_QUERY_GET								0x00001b0c
 
 
 #define NV50_COMPUTE									0x000050c0
@@ -8003,4 +8382,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 
 
+#define NVA0TCL										0x00008397
+
+
+
 #endif /* NOUVEAU_REG_H */
diff --git a/libdrm/nouveau/nouveau_device.c b/libdrm/nouveau/nouveau_device.c
index 6b99e36..0982d3b 100644
--- a/libdrm/nouveau/nouveau_device.c
+++ b/libdrm/nouveau/nouveau_device.c
@@ -26,7 +26,7 @@
 
 #include "nouveau_private.h"
 
-#if NOUVEAU_DRM_HEADER_PATCHLEVEL != 14
+#if NOUVEAU_DRM_HEADER_PATCHLEVEL != 15
 #error nouveau_drm.h does not match expected patchlevel, update libdrm.
 #endif
 
@@ -61,14 +61,6 @@ nouveau_device_open_existing(struct nouveau_device **dev, int close,
 	}
 
 	ret = nouveau_device_get_param(&nvdev->base,
-				       NOUVEAU_GETPARAM_MM_ENABLED, &value);
-	if (ret) {
-		nouveau_device_close((void *)&nvdev);
-		return ret;
-	}
-	nvdev->mm_enabled = value;
-
-	ret = nouveau_device_get_param(&nvdev->base,
 				       NOUVEAU_GETPARAM_VM_VRAM_BASE, &value);
 	if (ret) {
 		nouveau_device_close((void *)&nvdev);
diff --git a/libdrm/nouveau/nouveau_dma.c b/libdrm/nouveau/nouveau_dma.c
deleted file mode 100644
index b084f70..0000000
--- a/libdrm/nouveau/nouveau_dma.c
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Copyright 2007 Nouveau Project
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#include <stdint.h>
-#include <stdio.h>
-#include <assert.h>
-#include <errno.h>
-
-#include "nouveau_drmif.h"
-#include "nouveau_dma.h"
-
-static inline uint32_t
-READ_GET(struct nouveau_channel_priv *nvchan)
-{
-	return *nvchan->get;
-}
-
-static inline void
-WRITE_PUT(struct nouveau_channel_priv *nvchan, uint32_t val)
-{
-	uint32_t put = ((val << 2) + nvchan->dma->base);
-	volatile int dum;
-
-	NOUVEAU_DMA_BARRIER;
-	dum = nvchan->pushbuf[0];
-	dum = READ_GET(nvchan);
-
-	*nvchan->put = put;
-	nvchan->dma->put = val;
-#ifdef NOUVEAU_DMA_TRACE
-	printf("WRITE_PUT %d/0x%08x\n", nvchan->drm.channel, put);
-#endif
-
-	NOUVEAU_DMA_BARRIER;
-}
-
-static inline int
-LOCAL_GET(struct nouveau_dma_priv *dma, uint32_t *val)
-{
-	uint32_t get = *val;
-
-	if (get >= dma->base && get <= (dma->base + (dma->max << 2))) {
-		*val = (get - dma->base) >> 2;
-		return 1;
-	}
-
-	return 0;
-}
-
-void
-nouveau_dma_channel_init(struct nouveau_channel *chan)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-	int i;
-
-	nvchan->dma = &nvchan->struct_dma;
-	nvchan->dma->base = nvchan->drm.put_base;
-	nvchan->dma->cur  = nvchan->dma->put = 0;
-	nvchan->dma->max  = (nvchan->drm.cmdbuf_size >> 2) - 2;
-	nvchan->dma->free = nvchan->dma->max - nvchan->dma->cur;
-
-	RING_SPACE_CH(chan, RING_SKIPS);
-	for (i = 0; i < RING_SKIPS; i++)
-		OUT_RING_CH(chan, 0);
-}
-
-#define CHECK_TIMEOUT() do {                                                   \
-	if ((NOUVEAU_TIME_MSEC() - t_start) > NOUVEAU_DMA_TIMEOUT)             \
-		return - EBUSY;                                                \
-} while(0)
-
-int
-nouveau_dma_wait(struct nouveau_channel *chan, unsigned size)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-	struct nouveau_dma_priv *dma = nvchan->dma;
-	uint32_t get, t_start;
-
-	FIRE_RING_CH(chan);
-
-	t_start = NOUVEAU_TIME_MSEC();
-	while (dma->free < size) {
-		CHECK_TIMEOUT();
-
-		get = READ_GET(nvchan);
-		if (!LOCAL_GET(dma, &get))
-			continue;
-
-		if (dma->put >= get) {
-			dma->free = dma->max - dma->cur;
-
-			if (dma->free < size) {
-#ifdef NOUVEAU_DMA_DEBUG
-				dma->push_free = 1;
-#endif
-				OUT_RING_CH(chan, 0x20000000 | dma->base);
-				if (get <= RING_SKIPS) {
-					/*corner case - will be idle*/
-					if (dma->put <= RING_SKIPS)
-						WRITE_PUT(nvchan,
-							  RING_SKIPS + 1);
-
-					do {
-						CHECK_TIMEOUT();
-						get = READ_GET(nvchan);
-						if (!LOCAL_GET(dma, &get))
-							get = 0;
-					} while (get <= RING_SKIPS);
-				}
-
-				WRITE_PUT(nvchan, RING_SKIPS);
-				dma->cur  = dma->put = RING_SKIPS;
-				dma->free = get - (RING_SKIPS + 1);
-			}
-		} else {
-			dma->free = get - dma->cur - 1;
-		}
-	}
-
-	return 0;
-}
-
-#ifdef NOUVEAU_DMA_DUMP_POSTRELOC_PUSHBUF
-static void
-nouveau_dma_parse_pushbuf(struct nouveau_channel *chan, int get, int put)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-	unsigned mthd_count = 0;
-	
-	while (get != put) {
-		uint32_t gpuget = (get << 2) + nvchan->drm.put_base;
-		uint32_t data;
-
-		if (get < 0 || get >= nvchan->drm.cmdbuf_size)
-			assert(0);
-		data = nvchan->pushbuf[get++];
-
-		if (mthd_count) {
-			printf("0x%08x 0x%08x\n", gpuget, data);
-			mthd_count--;
-			continue;
-		}
-
-		switch (data & 0x60000000) {
-		case 0x00000000:
-			mthd_count = (data >> 18) & 0x7ff;
-			printf("0x%08x 0x%08x MTHD "
-			       "Sc %d Mthd 0x%04x Size %d\n",
-			       gpuget, data, (data>>13) & 7, data & 0x1ffc,
-			       mthd_count);
-			break;
-		case 0x20000000:
-			get = (data & 0x1ffffffc) >> 2;
-			printf("0x%08x 0x%08x JUMP 0x%08x\n",
-			       gpuget, data, data & 0x1ffffffc);
-			continue;
-		case 0x40000000:
-			mthd_count = (data >> 18) & 0x7ff;
-			printf("0x%08x 0x%08x NINC "
-			       "Sc %d Mthd 0x%04x Size %d\n",
-			       gpuget, data, (data>>13) & 7, data & 0x1ffc,
-			       mthd_count);
-			break;
-		case 0x60000000:
-			/* DMA_OPCODE_CALL apparently, doesn't seem to work on
-			 * my NV40 at least..
-			 */
-			/* fall-through */
-		default:
-			printf("DMA_PUSHER 0x%08x 0x%08x\n", gpuget, data);
-			assert(0);
-		}
-	}
-}
-#endif
-
-void
-nouveau_dma_kickoff(struct nouveau_channel *chan)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-	struct nouveau_dma_priv *dma = nvchan->dma;
-
-	if (dma->cur == dma->put)
-		return;
-
-#ifdef NOUVEAU_DMA_DEBUG
-	if (dma->push_free) {
-		printf("Packet incomplete: %d left\n", dma->push_free);
-		return;
-	}
-#endif
-
-#ifdef NOUVEAU_DMA_DUMP_POSTRELOC_PUSHBUF
-	nouveau_dma_parse_pushbuf(chan, dma->put, dma->cur);
-#endif
-
-	WRITE_PUT(nvchan, dma->cur);
-}
diff --git a/libdrm/nouveau/nouveau_dma.h b/libdrm/nouveau/nouveau_dma.h
deleted file mode 100644
index 38fe1d6..0000000
--- a/libdrm/nouveau/nouveau_dma.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright 2007 Nouveau Project
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#ifndef __NOUVEAU_DMA_H__
-#define __NOUVEAU_DMA_H__
-
-#include <string.h>
-#include "nouveau_private.h"
-
-//#define NOUVEAU_DMA_DEBUG
-//#define NOUVEAU_DMA_TRACE
-//#define NOUVEAU_DMA_DUMP_POSTRELOC_PUSHBUF
-#if defined(__amd64__)
-#define NOUVEAU_DMA_BARRIER asm volatile("lock; addl $0,0(%%rsp)" ::: "memory")
-#elif defined(__i386__)
-#define NOUVEAU_DMA_BARRIER asm volatile("lock; addl $0,0(%%esp)" ::: "memory")
-#else
-#define NOUVEAU_DMA_BARRIER
-#endif
-#define NOUVEAU_DMA_TIMEOUT 2000
-#define NOUVEAU_TIME_MSEC() 0
-#define RING_SKIPS 8
-
-extern int  nouveau_dma_wait(struct nouveau_channel *chan, unsigned size);
-extern void nouveau_dma_subc_bind(struct nouveau_grobj *);
-extern void nouveau_dma_channel_init(struct nouveau_channel *);
-extern void nouveau_dma_kickoff(struct nouveau_channel *);
-
-#ifdef NOUVEAU_DMA_DEBUG
-static char faulty[1024];
-#endif
-
-static inline void
-nouveau_dma_out(struct nouveau_channel *chan, uint32_t data)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-	struct nouveau_dma_priv *dma = nvchan->dma;
-
-#ifdef NOUVEAU_DMA_DEBUG
-	if (dma->push_free == 0) {
-		printf("No space left in packet at %s\n", faulty);
-		return;
-	}
-	dma->push_free--;
-#endif
-#ifdef NOUVEAU_DMA_TRACE
-	{
-		uint32_t offset = (dma->cur << 2) + dma->base;
-		printf("\tOUT_RING %d/0x%08x -> 0x%08x\n",
-		       nvchan->drm.channel, offset, data);
-	}
-#endif
-	nvchan->pushbuf[dma->cur + (dma->base - nvchan->drm.put_base)/4] = data;
-	dma->cur++;
-}
-
-static inline void
-nouveau_dma_outp(struct nouveau_channel *chan, uint32_t *ptr, int size)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-	struct nouveau_dma_priv *dma = nvchan->dma;
-	(void)dma;
-
-#ifdef NOUVEAU_DMA_DEBUG
-	if (dma->push_free < size) {
-		printf("Packet too small.  Free=%d, Need=%d\n",
-		       dma->push_free, size);
-		return;
-	}
-#endif
-#ifdef NOUVEAU_DMA_TRACE
-	while (size--) {
-		nouveau_dma_out(chan, *ptr);
-		ptr++;
-	}
-#else
-	memcpy(&nvchan->pushbuf[dma->cur], ptr, size << 2);
-#ifdef NOUVEAU_DMA_DEBUG
-	dma->push_free -= size;
-#endif
-	dma->cur += size;
-#endif
-}
-
-static inline void
-nouveau_dma_space(struct nouveau_channel *chan, unsigned size)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-	struct nouveau_dma_priv *dma = nvchan->dma;
-
-	if (dma->free < size) {
-		if (nouveau_dma_wait(chan, size) && chan->hang_notify)
-			chan->hang_notify(chan);
-	}
-	dma->free -= size;
-#ifdef NOUVEAU_DMA_DEBUG
-	dma->push_free = size;
-#endif
-}
-
-static inline void
-nouveau_dma_begin(struct nouveau_channel *chan, struct nouveau_grobj *grobj,
-		  int method, int size, const char* file, int line)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-	struct nouveau_dma_priv *dma = nvchan->dma;
-	(void)dma;
-
-#ifdef NOUVEAU_DMA_TRACE
-	printf("BEGIN_RING %d/%08x/%d/0x%04x/%d\n", nvchan->drm.channel,
-	       grobj->handle, grobj->subc, method, size);
-#endif
-
-#ifdef NOUVEAU_DMA_DEBUG
-	if (dma->push_free) {
-		printf("Previous packet incomplete: %d left at %s\n",
-		       dma->push_free, faulty);
-		return;
-	}
-	sprintf(faulty,"%s:%d",file,line);
-#endif
-
-	nouveau_dma_space(chan, (size + 1));
-	nouveau_dma_out(chan, (size << 18) | (grobj->subc << 13) | method);
-}
-
-#define RING_SPACE_CH(ch,sz)         nouveau_dma_space((ch), (sz))
-#define BEGIN_RING_CH(ch,gr,m,sz)    nouveau_dma_begin((ch), (gr), (m), (sz), __FUNCTION__, __LINE__ )
-#define OUT_RING_CH(ch, data)        nouveau_dma_out((ch), (data))
-#define OUT_RINGp_CH(ch,ptr,dwords)  nouveau_dma_outp((ch), (void*)(ptr),      \
-						      (dwords))
-#define FIRE_RING_CH(ch)             nouveau_dma_kickoff((ch))
-#define WAIT_RING_CH(ch,sz)          nouveau_dma_wait((ch), (sz))
-		
-#endif
diff --git a/libdrm/nouveau/nouveau_drmif.h b/libdrm/nouveau/nouveau_drmif.h
index c21fba2..bc860d2 100644
--- a/libdrm/nouveau/nouveau_drmif.h
+++ b/libdrm/nouveau/nouveau_drmif.h
@@ -35,8 +35,6 @@ struct nouveau_device_priv {
 	drm_context_t ctx;
 	drmLock *lock;
 	int needs_close;
-
-	int mm_enabled;
 };
 #define nouveau_device(n) ((struct nouveau_device_priv *)(n))
 
diff --git a/libdrm/nouveau/nouveau_fence.c b/libdrm/nouveau/nouveau_fence.c
deleted file mode 100644
index 3346616..0000000
--- a/libdrm/nouveau/nouveau_fence.c
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright 2007 Nouveau Project
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <assert.h>
-
-#include "nouveau_private.h"
-#include "nouveau_dma.h"
-
-static void
-nouveau_fence_del_unsignalled(struct nouveau_fence *fence)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(fence->channel);
-	struct nouveau_fence *le;
-
-	if (nvchan->fence_head == fence) {
-		nvchan->fence_head = nouveau_fence(fence)->next;
-		if (nvchan->fence_head == NULL)
-			nvchan->fence_tail = NULL;
-		return;
-	}
-
-	le = nvchan->fence_head;
-	while (le && nouveau_fence(le)->next != fence)
-		le = nouveau_fence(le)->next;
-	assert(le && nouveau_fence(le)->next == fence);
-	nouveau_fence(le)->next = nouveau_fence(fence)->next;
-	if (nvchan->fence_tail == fence)
-		nvchan->fence_tail = le;
-}
-
-static void
-nouveau_fence_del(struct nouveau_fence **fence)
-{
-	struct nouveau_fence_priv *nvfence;
-
-	if (!fence || !*fence)
-		return;
-	nvfence = nouveau_fence(*fence);
-	*fence = NULL;
-
-	if (--nvfence->refcount)
-		return;
-
-	if (nvfence->emitted && !nvfence->signalled) {
-		if (nvfence->signal_cb) {
-			nvfence->refcount++;
-			nouveau_fence_wait((void *)&nvfence);
-			return;
-		}
-
-		nouveau_fence_del_unsignalled(&nvfence->base);
-	}
-	free(nvfence);
-}
-
-int
-nouveau_fence_new(struct nouveau_channel *chan, struct nouveau_fence **fence)
-{
-	struct nouveau_fence_priv *nvfence;
-
-	if (!chan || !fence || *fence)
-		return -EINVAL;
-	
-	nvfence = calloc(1, sizeof(struct nouveau_fence_priv));
-	if (!nvfence)
-		return -ENOMEM;
-	nvfence->base.channel = chan;
-	nvfence->refcount = 1;
-
-	*fence = &nvfence->base;
-	return 0;
-}
-
-int
-nouveau_fence_ref(struct nouveau_fence *ref, struct nouveau_fence **fence)
-{
-	if (!fence)
-		return -EINVAL;
-
-	if (ref)
-		nouveau_fence(ref)->refcount++;
-
-	if (*fence)
-		nouveau_fence_del(fence);
-
-	*fence = ref;
-	return 0;
-}
-
-int
-nouveau_fence_signal_cb(struct nouveau_fence *fence, void (*func)(void *),
-			void *priv)
-{
-	struct nouveau_fence_priv *nvfence = nouveau_fence(fence);
-	struct nouveau_fence_cb *cb;
-
-	if (!nvfence || !func)
-		return -EINVAL;
-
-	cb = malloc(sizeof(struct nouveau_fence_cb));
-	if (!cb)
-		return -ENOMEM;
-
-	cb->func = func;
-	cb->priv = priv;
-	cb->next = nvfence->signal_cb;
-	nvfence->signal_cb = cb;
-	return 0;
-}
-
-void
-nouveau_fence_emit(struct nouveau_fence *fence)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(fence->channel);
-	struct nouveau_fence_priv *nvfence = nouveau_fence(fence);
-
-	nvfence->emitted = 1;
-	nvfence->sequence = ++nvchan->fence_sequence;
-	if (nvfence->sequence == 0xffffffff)
-		printf("AII wrap unhandled\n");
-
-	if (!nvchan->fence_ntfy) {
-		/*XXX: assumes subc 0 is populated */
-		nouveau_dma_space(fence->channel, 2);
-		nouveau_dma_out  (fence->channel, 0x00040050);
-		nouveau_dma_out  (fence->channel, nvfence->sequence);
-	}
-	nouveau_dma_kickoff(fence->channel);
-
-	if (nvchan->fence_tail) {
-		nouveau_fence(nvchan->fence_tail)->next = fence;
-	} else {
-		nvchan->fence_head = fence;
-	}
-	nvchan->fence_tail = fence;
-}
-
-static void
-nouveau_fence_flush_seq(struct nouveau_channel *chan, uint32_t sequence)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-
-	while (nvchan->fence_head) {
-		struct nouveau_fence_priv *nvfence;
-	
-		nvfence = nouveau_fence(nvchan->fence_head);
-		if (nvfence->sequence > sequence)
-			break;
-		nouveau_fence_del_unsignalled(&nvfence->base);
-		nvfence->signalled = 1;
-
-		if (nvfence->signal_cb) {
-			struct nouveau_fence *fence = NULL;
-
-			nouveau_fence_ref(&nvfence->base, &fence);
-
-			while (nvfence->signal_cb) {
-				struct nouveau_fence_cb *cb;
-				
-				cb = nvfence->signal_cb;
-				nvfence->signal_cb = cb->next;
-				cb->func(cb->priv);
-				free(cb);
-			}
-
-			nouveau_fence_ref(NULL, &fence);
-		}
-	}
-}
-
-void
-nouveau_fence_flush(struct nouveau_channel *chan)
-{
-	struct nouveau_channel_priv *nvchan = nouveau_channel(chan);
-
-	if (!nvchan->fence_ntfy)
-		nouveau_fence_flush_seq(chan, *nvchan->ref_cnt);
-}
-
-int
-nouveau_fence_wait(struct nouveau_fence **fence)
-{
-	struct nouveau_fence_priv *nvfence;
-	struct nouveau_channel_priv *nvchan;
-
-	if (!fence)
-		return -EINVAL;
-
-	nvfence = nouveau_fence(*fence);
-	if (!nvfence)
-		return 0;
-	nvchan = nouveau_channel(nvfence->base.channel);
-
-	if (nvfence->emitted) {
-		if (!nvfence->signalled && nvchan->fence_ntfy) {
-			struct nouveau_channel *chan = &nvchan->base;
-			int ret;
- 
-			/*XXX: NV04/NV05: Full sync + flush all fences */
-			nouveau_notifier_reset(nvchan->fence_ntfy, 0);
-			BEGIN_RING(chan, nvchan->fence_grobj, 0x0104, 1);
-			OUT_RING  (chan, 0);
-			BEGIN_RING(chan, nvchan->fence_grobj, 0x0100, 1);
-			OUT_RING  (chan, 0);
-			FIRE_RING (chan);
-			ret = nouveau_notifier_wait_status(nvchan->fence_ntfy,
-							   0, 0, 2.0);
-			if (ret)
-				return ret;
- 
-			nouveau_fence_flush_seq(chan, nvchan->fence_sequence);
-		}
-
-		while (!nvfence->signalled)
-			nouveau_fence_flush(nvfence->base.channel);
-	}
-
-	nouveau_fence_ref(NULL, fence);
-	return 0;
-}
-
diff --git a/libdrm/nouveau/nouveau_notifier.c b/libdrm/nouveau/nouveau_notifier.c
index 8f1d535..f8cfd8b 100644
--- a/libdrm/nouveau/nouveau_notifier.c
+++ b/libdrm/nouveau/nouveau_notifier.c
@@ -48,7 +48,7 @@ nouveau_notifier_alloc(struct nouveau_channel *chan, uint32_t handle,
 
 	nvnotify->drm.channel = chan->id;
 	nvnotify->drm.handle  = handle;
-	nvnotify->drm.count   = count;
+	nvnotify->drm.size    = (count * 32);
 	if ((ret = drmCommandWriteRead(nouveau_device(chan->device)->fd,
 				       DRM_NOUVEAU_NOTIFIEROBJ_ALLOC,
 				       &nvnotify->drm,
@@ -57,7 +57,7 @@ nouveau_notifier_alloc(struct nouveau_channel *chan, uint32_t handle,
 		return ret;
 	}
 
-	nvnotify->map = (char *)nouveau_channel(chan)->notifier_block +
+	nvnotify->map = (char *)nouveau_channel(chan)->notifier_bo->map +
 				nvnotify->drm.offset;
 	*notifier = &nvnotify->base;
 	return 0;
diff --git a/libdrm/nouveau/nouveau_private.h b/libdrm/nouveau/nouveau_private.h
index e92cb1f..49dde5e 100644
--- a/libdrm/nouveau/nouveau_private.h
+++ b/libdrm/nouveau/nouveau_private.h
@@ -36,8 +36,6 @@
 #include "nouveau_resource.h"
 #include "nouveau_pushbuf.h"
 
-#define NOUVEAU_PUSHBUF_MAX_BUFFERS 1024
-#define NOUVEAU_PUSHBUF_MAX_RELOCS 1024
 struct nouveau_pushbuf_priv {
 	struct nouveau_pushbuf base;
 
@@ -51,95 +49,23 @@ struct nouveau_pushbuf_priv {
 	unsigned nr_buffers;
 	struct drm_nouveau_gem_pushbuf_reloc *relocs;
 	unsigned nr_relocs;
-
-	/*XXX: nomm */
-	struct nouveau_fence *fence;
 };
 #define nouveau_pushbuf(n) ((struct nouveau_pushbuf_priv *)(n))
 
-#define pbbo_to_ptr(o) ((uint64_t)(unsigned long)(o))
-#define ptr_to_pbbo(h) ((struct nouveau_pushbuf_bo *)(unsigned long)(h))
-#define pbrel_to_ptr(o) ((uint64_t)(unsigned long)(o))
-#define ptr_to_pbrel(h) ((struct nouveau_pushbuf_reloc *)(unsigned long)(h))
-#define bo_to_ptr(o) ((uint64_t)(unsigned long)(o))
-#define ptr_to_bo(h) ((struct nouveau_bo_priv *)(unsigned long)(h))
-
 int
 nouveau_pushbuf_init(struct nouveau_channel *);
 
-struct nouveau_dma_priv {
-	uint32_t base;
-	uint32_t max;
-	uint32_t cur;
-	uint32_t put;
-	uint32_t free;
-
-	int push_free;
-} dma;
-
 struct nouveau_channel_priv {
 	struct nouveau_channel base;
 
 	struct drm_nouveau_channel_alloc drm;
 
-	void     *notifier_block;
+	struct nouveau_bo *notifier_bo;
 
 	struct nouveau_pushbuf_priv pb;
-
-	/*XXX: nomm */
-	volatile uint32_t *user, *put, *get, *ref_cnt;
-	uint32_t *pushbuf;
-	struct nouveau_dma_priv struct_dma;
-	struct nouveau_dma_priv *dma;
-	struct nouveau_fence *fence_head;
-	struct nouveau_fence *fence_tail;
-	uint32_t fence_sequence;
-	struct nouveau_grobj *fence_grobj;
-	struct nouveau_notifier *fence_ntfy;
 };
 #define nouveau_channel(n) ((struct nouveau_channel_priv *)(n))
 
-struct nouveau_fence {
-	struct nouveau_channel *channel;
-};
-
-struct nouveau_fence_cb {
-	struct nouveau_fence_cb *next;
-	void (*func)(void *);
-	void *priv;
-};
-
-struct nouveau_fence_priv {
-	struct nouveau_fence base;
-	int refcount;
-
-	struct nouveau_fence *next;
-	struct nouveau_fence_cb *signal_cb;
-
-	uint32_t sequence;
-	int emitted;
-	int signalled;
-};
-#define nouveau_fence(n) ((struct nouveau_fence_priv *)(n))
-
-int
-nouveau_fence_new(struct nouveau_channel *, struct nouveau_fence **);
-
-int
-nouveau_fence_ref(struct nouveau_fence *, struct nouveau_fence **);
-
-int
-nouveau_fence_signal_cb(struct nouveau_fence *, void (*)(void *), void *);
-
-void
-nouveau_fence_emit(struct nouveau_fence *);
-
-int
-nouveau_fence_wait(struct nouveau_fence **);
-
-void
-nouveau_fence_flush(struct nouveau_channel *);
-
 struct nouveau_grobj_priv {
 	struct nouveau_grobj base;
 };
@@ -181,10 +107,6 @@ struct nouveau_bo_priv {
 	int pinned;
 	uint64_t offset;
 	uint32_t domain;
-
-	/*XXX: nomm stuff */
-	struct nouveau_fence *fence;
-	struct nouveau_fence *wr_fence;
 };
 #define nouveau_bo(n) ((struct nouveau_bo_priv *)(n))
 
@@ -197,8 +119,4 @@ nouveau_bo_takedown(struct nouveau_device *);
 struct drm_nouveau_gem_pushbuf_bo *
 nouveau_bo_emit_buffer(struct nouveau_channel *, struct nouveau_bo *);
 
-int
-nouveau_bo_validate_nomm(struct nouveau_bo_priv *, uint32_t);
-
-#include "nouveau_dma.h"
 #endif
diff --git a/libdrm/nouveau/nouveau_pushbuf.c b/libdrm/nouveau/nouveau_pushbuf.c
index fded21b..2a242f7 100644
--- a/libdrm/nouveau/nouveau_pushbuf.c
+++ b/libdrm/nouveau/nouveau_pushbuf.c
@@ -26,19 +26,15 @@
 #include <assert.h>
 
 #include "nouveau_private.h"
-#include "nouveau_dma.h"
 
 #define PB_BUFMGR_DWORDS   (4096 / 2)
 #define PB_MIN_USER_DWORDS  2048
 
 static uint32_t
 nouveau_pushbuf_calc_reloc(struct drm_nouveau_gem_pushbuf_bo *pbbo,
-			   struct drm_nouveau_gem_pushbuf_reloc *r,
-			   int mm_enabled)
+			   struct drm_nouveau_gem_pushbuf_reloc *r)
 {
 	uint32_t push = 0;
-	const unsigned is_vram = mm_enabled ? NOUVEAU_GEM_DOMAIN_VRAM :
-					      NOUVEAU_BO_VRAM;
 
 	if (r->flags & NOUVEAU_GEM_RELOC_LOW)
 		push = (pbbo->presumed_offset + r->data);
@@ -49,7 +45,7 @@ nouveau_pushbuf_calc_reloc(struct drm_nouveau_gem_pushbuf_bo *pbbo,
 		push = r->data;
 
 	if (r->flags & NOUVEAU_GEM_RELOC_OR) {
-		if (pbbo->presumed_domain & is_vram)
+		if (pbbo->presumed_domain & NOUVEAU_GEM_DOMAIN_VRAM)
 			push |= r->vor;
 		else
 			push |= r->tor;
@@ -69,7 +65,7 @@ nouveau_pushbuf_emit_reloc(struct nouveau_channel *chan, void *ptr,
 	struct drm_nouveau_gem_pushbuf_bo *pbbo;
 	uint32_t domains = 0;
 
-	if (nvpb->nr_relocs >= NOUVEAU_PUSHBUF_MAX_RELOCS)
+	if (nvpb->nr_relocs >= NOUVEAU_GEM_MAX_RELOCS)
 		return -ENOMEM;
 
 	if (nouveau_bo(bo)->user && (flags & NOUVEAU_BO_WR)) {
@@ -88,14 +84,6 @@ nouveau_pushbuf_emit_reloc(struct nouveau_channel *chan, void *ptr,
 	pbbo->valid_domains &= domains;
 	assert(pbbo->valid_domains);
 
-	if (!nvdev->mm_enabled) {
-		struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
-
-		nouveau_fence_ref(nvpb->fence, &nvbo->fence);
-		if (flags & NOUVEAU_BO_WR)
-			nouveau_fence_ref(nvpb->fence, &nvbo->wr_fence);
-	}
-
 	assert(flags & NOUVEAU_BO_RDWR);
 	if (flags & NOUVEAU_BO_RD) {
 		pbbo->read_domains |= domains;
@@ -120,7 +108,7 @@ nouveau_pushbuf_emit_reloc(struct nouveau_channel *chan, void *ptr,
 	r->tor = tor;
 
 	*(uint32_t *)ptr = (flags & NOUVEAU_BO_DUMMY) ? 0 :
-		nouveau_pushbuf_calc_reloc(pbbo, r, nvdev->mm_enabled);
+		nouveau_pushbuf_calc_reloc(pbbo, r);
 	return 0;
 }
 
@@ -142,11 +130,6 @@ nouveau_pushbuf_space(struct nouveau_channel *chan, unsigned min)
 	nvpb->base.remaining = nvpb->size;
 	nvpb->base.cur = nvpb->pushbuf;
 	
-	if (!nouveau_device(chan->device)->mm_enabled) {
-		nouveau_fence_ref(NULL, &nvpb->fence);
-		nouveau_fence_new(chan, &nvpb->fence);
-	}
-
 	return 0;
 }
 
@@ -158,63 +141,15 @@ nouveau_pushbuf_init(struct nouveau_channel *chan)
 
 	nouveau_pushbuf_space(chan, 0);
 
-	nvpb->buffers = calloc(NOUVEAU_PUSHBUF_MAX_BUFFERS,
+	nvpb->buffers = calloc(NOUVEAU_GEM_MAX_BUFFERS,
 			       sizeof(struct drm_nouveau_gem_pushbuf_bo));
-	nvpb->relocs = calloc(NOUVEAU_PUSHBUF_MAX_RELOCS,
+	nvpb->relocs = calloc(NOUVEAU_GEM_MAX_RELOCS,
 			      sizeof(struct drm_nouveau_gem_pushbuf_reloc));
 	
 	chan->pushbuf = &nvpb->base;
 	return 0;
 }
 
-static int
-nouveau_pushbuf_flush_nomm(struct nouveau_channel_priv *nvchan)
-{
-	struct nouveau_pushbuf_priv *nvpb = &nvchan->pb;
-	struct drm_nouveau_gem_pushbuf_bo *bo = nvpb->buffers;
-	struct drm_nouveau_gem_pushbuf_reloc *reloc = nvpb->relocs;
-	unsigned b, r;
-	int ret;
-
-	for (b = 0; b < nvpb->nr_buffers; b++) {
-		struct nouveau_bo_priv *nvbo =
-			(void *)(unsigned long)bo[b].user_priv;
-		uint32_t flags = 0;
-
-		if (bo[b].valid_domains & NOUVEAU_GEM_DOMAIN_VRAM)
-			flags |= NOUVEAU_BO_VRAM;
-		if (bo[b].valid_domains & NOUVEAU_GEM_DOMAIN_GART)
-			flags |= NOUVEAU_BO_GART;
-
-		ret = nouveau_bo_validate_nomm(nvbo, flags);
-		if (ret)
-			return ret;
-
-		if (1 || bo[b].presumed_domain != nvbo->domain ||
-		    bo[b].presumed_offset != nvbo->offset) {
-			bo[b].presumed_ok = 0;
-			bo[b].presumed_domain = nvbo->domain;
-			bo[b].presumed_offset = nvbo->offset;
-		}
-	}
-
-	for (r = 0; r < nvpb->nr_relocs; r++, reloc++) {
-		uint32_t push;
-
-		if (bo[reloc->bo_index].presumed_ok)
-			continue;
-
-		push = nouveau_pushbuf_calc_reloc(&bo[reloc->bo_index], reloc, 0);
-		nvpb->pushbuf[reloc->reloc_index] = push;
-	}
-
-	nouveau_dma_space(&nvchan->base, nvpb->size);
-	nouveau_dma_outp (&nvchan->base, nvpb->pushbuf, nvpb->size);
-	nouveau_fence_emit(nvpb->fence);
-
-	return 0;
-}
-
 int
 nouveau_pushbuf_flush(struct nouveau_channel *chan, unsigned min)
 {
@@ -229,20 +164,15 @@ nouveau_pushbuf_flush(struct nouveau_channel *chan, unsigned min)
 		return 0;
 	nvpb->size -= nvpb->base.remaining;
 
-	if (nvdev->mm_enabled) {
-		req.channel = chan->id;
-		req.nr_dwords = nvpb->size;
-		req.dwords = (uint64_t)(unsigned long)nvpb->pushbuf;
-		req.nr_buffers = nvpb->nr_buffers;
-		req.buffers = (uint64_t)(unsigned long)nvpb->buffers;
-		req.nr_relocs = nvpb->nr_relocs;
-		req.relocs = (uint64_t)(unsigned long)nvpb->relocs;
-		ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_PUSHBUF,
-				      &req, sizeof(req));
-	} else {
-		nouveau_fence_flush(chan);
-		ret = nouveau_pushbuf_flush_nomm(nvchan);
-	}
+	req.channel = chan->id;
+	req.nr_dwords = nvpb->size;
+	req.dwords = (uint64_t)(unsigned long)nvpb->pushbuf;
+	req.nr_buffers = nvpb->nr_buffers;
+	req.buffers = (uint64_t)(unsigned long)nvpb->buffers;
+	req.nr_relocs = nvpb->nr_relocs;
+	req.relocs = (uint64_t)(unsigned long)nvpb->relocs;
+	ret = drmCommandWrite(nvdev->fd, DRM_NOUVEAU_GEM_PUSHBUF,
+			      &req, sizeof(req));
 	assert(ret == 0);
 
 
diff --git a/shared-core/nouveau_drm.h b/shared-core/nouveau_drm.h
index dc6a194..3e52b24 100644
--- a/shared-core/nouveau_drm.h
+++ b/shared-core/nouveau_drm.h
@@ -25,7 +25,7 @@
 #ifndef __NOUVEAU_DRM_H__
 #define __NOUVEAU_DRM_H__
 
-#define NOUVEAU_DRM_HEADER_PATCHLEVEL 14
+#define NOUVEAU_DRM_HEADER_PATCHLEVEL 15
 
 struct drm_nouveau_channel_alloc {
 	uint32_t     fb_ctxdma_handle;
@@ -34,8 +34,7 @@ struct drm_nouveau_channel_alloc {
 	int          channel;
 
 	/* Notifier memory */
-	drm_handle_t notifier;
-	int          notifier_size;
+	uint32_t     notifier_handle;
 
 	/* DRM-enforced subchannel assignments */
 	struct {
@@ -43,15 +42,6 @@ struct drm_nouveau_channel_alloc {
 		uint32_t grclass;
 	} subchan[8];
 	uint32_t nr_subchan;
-
-/* !MM_ENABLED ONLY */
-	uint32_t     put_base;
-	/* FIFO control regs */
-	drm_handle_t ctrl;
-	int          ctrl_size;
-	/* DMA command buffer */
-	drm_handle_t cmdbuf;
-	int          cmdbuf_size;
 };
 
 struct drm_nouveau_channel_free {
@@ -64,14 +54,10 @@ struct drm_nouveau_grobj_alloc {
 	int      class;
 };
 
-#define NOUVEAU_MEM_ACCESS_RO	1
-#define NOUVEAU_MEM_ACCESS_WO	2
-#define NOUVEAU_MEM_ACCESS_RW	3
 struct drm_nouveau_notifierobj_alloc {
-	int      channel;
+	uint32_t channel;
 	uint32_t handle;
-	int      count;
-
+	uint32_t size;
 	uint32_t offset;
 };
 
@@ -80,52 +66,6 @@ struct drm_nouveau_gpuobj_free {
 	uint32_t handle;
 };
 
-/* This is needed to avoid a race condition.
- * Otherwise you may be writing in the fetch area.
- * Is this large enough, as it's only 32 bytes, and the maximum fetch size is 256 bytes?
- */
-#define NOUVEAU_DMA_SKIPS 8
-
-#define NOUVEAU_MEM_FB			0x00000001
-#define NOUVEAU_MEM_AGP			0x00000002
-#define NOUVEAU_MEM_FB_ACCEPTABLE	0x00000004
-#define NOUVEAU_MEM_AGP_ACCEPTABLE	0x00000008
-#define NOUVEAU_MEM_PCI			0x00000010
-#define NOUVEAU_MEM_PCI_ACCEPTABLE	0x00000020
-#define NOUVEAU_MEM_PINNED		0x00000040
-#define NOUVEAU_MEM_USER_BACKED		0x00000080
-#define NOUVEAU_MEM_MAPPED		0x00000100
-#define NOUVEAU_MEM_TILE		0x00000200
-#define NOUVEAU_MEM_TILE_ZETA		0x00000400
-#define NOUVEAU_MEM_INSTANCE		0x01000000 /* internal */
-#define NOUVEAU_MEM_NOTIFIER            0x02000000 /* internal */
-#define NOUVEAU_MEM_NOVM		0x04000000 /* internal */
-#define NOUVEAU_MEM_USER		0x08000000 /* internal */
-#define NOUVEAU_MEM_INTERNAL (NOUVEAU_MEM_INSTANCE | \
-			      NOUVEAU_MEM_NOTIFIER | \
-			      NOUVEAU_MEM_NOVM | \
-			      NOUVEAU_MEM_USER)
-
-struct drm_nouveau_mem_alloc {
-	int flags;
-	int alignment;
-	uint64_t size;	// in bytes
-	uint64_t offset;
-	drm_handle_t map_handle;
-};
-
-struct drm_nouveau_mem_free {
-	uint64_t offset;
-	int flags;
-};
-
-struct drm_nouveau_mem_tile {
-	uint64_t offset;
-	uint64_t delta;
-	uint64_t size;
-	int flags;
-};
-
 /* FIXME : maybe unify {GET,SET}PARAMs */
 #define NOUVEAU_GETPARAM_PCI_VENDOR      3
 #define NOUVEAU_GETPARAM_PCI_DEVICE      4
@@ -136,15 +76,12 @@ struct drm_nouveau_mem_tile {
 #define NOUVEAU_GETPARAM_AGP_SIZE        9
 #define NOUVEAU_GETPARAM_PCI_PHYSICAL    10
 #define NOUVEAU_GETPARAM_CHIPSET_ID      11
-#define NOUVEAU_GETPARAM_MM_ENABLED      12
-#define NOUVEAU_GETPARAM_VM_VRAM_BASE    13
+#define NOUVEAU_GETPARAM_VM_VRAM_BASE    12
 struct drm_nouveau_getparam {
 	uint64_t param;
 	uint64_t value;
 };
 
-#define NOUVEAU_SETPARAM_CMDBUF_LOCATION 1
-#define NOUVEAU_SETPARAM_CMDBUF_SIZE     2
 struct drm_nouveau_setparam {
 	uint64_t param;
 	uint64_t value;
@@ -228,8 +165,12 @@ struct drm_nouveau_gem_unpin {
 	uint32_t handle;
 };
 
+#define NOUVEAU_GEM_CPU_PREP_NOWAIT                                  0x00000001
+#define NOUVEAU_GEM_CPU_PREP_NOBLOCK                                 0x00000002
+#define NOUVEAU_GEM_CPU_PREP_WRITE                                   0x00000004
 struct drm_nouveau_gem_cpu_prep {
 	uint32_t handle;
+	uint32_t flags;
 };
 
 struct drm_nouveau_gem_cpu_fini {
@@ -238,38 +179,19 @@ struct drm_nouveau_gem_cpu_fini {
 
 struct drm_nouveau_gem_tile {
 	uint32_t handle;
-	uint32_t delta;
+	uint32_t offset;
 	uint32_t size;
-	uint32_t flags;
-};
-
-enum nouveau_card_type {
-	NV_UNKNOWN =0,
-	NV_04      =4,
-	NV_05      =5,
-	NV_10      =10,
-	NV_11      =11,
-	NV_17      =17,
-	NV_20      =20,
-	NV_30      =30,
-	NV_40      =40,
-	NV_44      =44,
-	NV_50      =50,
-	NV_LAST    =0xffff,
+	uint32_t tile_mode;
+	uint32_t tile_flags;
 };
 
 enum nouveau_bus_type {
-	NV_AGP     =0,
-	NV_PCI     =1,
-	NV_PCIE    =2,
+	NV_AGP     = 0,
+	NV_PCI     = 1,
+	NV_PCIE    = 2,
 };
 
-#define NOUVEAU_MAX_SAREA_CLIPRECTS 16
-
 struct drm_nouveau_sarea {
-	/* the cliprects */
-	struct drm_clip_rect boxes[NOUVEAU_MAX_SAREA_CLIPRECTS];
-	unsigned int nbox;
 };
 
 #define DRM_NOUVEAU_CARD_INIT          0x00
@@ -280,19 +202,13 @@ struct drm_nouveau_sarea {
 #define DRM_NOUVEAU_GROBJ_ALLOC        0x05
 #define DRM_NOUVEAU_NOTIFIEROBJ_ALLOC  0x06
 #define DRM_NOUVEAU_GPUOBJ_FREE        0x07
-#define DRM_NOUVEAU_MEM_ALLOC          0x08
-#define DRM_NOUVEAU_MEM_FREE           0x09
-#define DRM_NOUVEAU_MEM_TILE           0x0a
-#define DRM_NOUVEAU_SUSPEND            0x0b
-#define DRM_NOUVEAU_RESUME             0x0c
 #define DRM_NOUVEAU_GEM_NEW            0x40
 #define DRM_NOUVEAU_GEM_PUSHBUF        0x41
 #define DRM_NOUVEAU_GEM_PUSHBUF_CALL   0x42
-#define DRM_NOUVEAU_GEM_PIN            0x43
-#define DRM_NOUVEAU_GEM_UNPIN          0x44
+#define DRM_NOUVEAU_GEM_PIN            0x43 /* !KMS only */
+#define DRM_NOUVEAU_GEM_UNPIN          0x44 /* !KMS only */
 #define DRM_NOUVEAU_GEM_CPU_PREP       0x45
 #define DRM_NOUVEAU_GEM_CPU_FINI       0x46
-#define DRM_NOUVEAU_GEM_TILE           0x47
-#define DRM_NOUVEAU_GEM_INFO           0x48
+#define DRM_NOUVEAU_GEM_INFO           0x47
 
 #endif /* __NOUVEAU_DRM_H__ */
